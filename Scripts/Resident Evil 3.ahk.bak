sleep 2000
h_game := get_process_handle("ResidentEvil3.exe") 
id_game := get_process_ID("ResidentEvil3.exe")

setformat, integer, hex
_add := aobscan(h_game, id_game, "ResidentEvil3.exe", memlib_String2ByteArray("66 0F B6 50 09 66 89 15"),"peixoto.dll") + 8 
re3_room := read_process_memory(h_game, _add, "uint")
room := "0x"
for k, v in ReverseInt32bytes(re3_room)
{
	stringreplace, v, v, 0x, ,
	room .= v
}
hwin := g_globals.script_hwnd
DetectHiddenWindows, On
WinSetTitle, ahk_id %hwin%, ,%re3_room%
return
    

;REMOTE SCRIPT START
if g_globals.config.create_links
{
	FileDelete, *.sav
	CreateLinksCollection(["bu00.sav", "bu10.sav"],"ResidentEvil3")
}

g_globals.RE_shader_code :=
(
"
sampler s0 : register(s0);
sampler s4 : register(s4);
sampler s5 : register(s5);
float4 main(float2 tex : TEXCOORD0, float4 diff : COLOR0, float2 pos : VPOS) : COLOR
{
	float4 magenta  = float4(1., 0., 1., 1.);
	float4 green    = float4(0., 1., 0., 1.);
	float4 c0       = tex2D(s0, tex);
	float4 c4       = tex2D(s4, tex);	
	float2 size = float2(640., 480.);	
	if ( all(c0.rgb == magenta.rgb) )
		return tex2D(s5, pos/size);	
	if ( all(c0.rgb == magenta.rgb) )
		return c0*diff;			
	return float4(c4.rgb*diff.rgb, c4.a);
}
"
)

DetectHiddenWindows, On
global RE3_surfdesc   := struct(DDSURFACEDESC2)
RE3_surfdesc.dwSize   := DDSURFACEDESC2.size()
global RE3_rect       := struct("rect[16]")
global RE3_dest_rect  := struct("rect[16]")
global RE3_rectb      := struct("rect[4]")
global RE3_dest_rectb := struct("rect[4]")
x := 0, y := 0, w := 256, h := 256, n := 1
loop, 4
{
	loop, 4
	{
		RE3_rect[n].left   := x
		RE3_rect[n].right  := w
		RE3_rect[n].top    := y
		RE3_rect[n].bottom := h
		
		w += 256
		x += 256
		n += 1
	}
	y += 256
	h += 256
	x := 0
	w := 256
}

x := 0, y := 0, w := g_globals.config.textsize, h := g_globals.config.textsize, n := 1
loop, 4
{
	loop, 4
	{
		RE3_dest_rect[n].left   := x
		RE3_dest_rect[n].right  := w
		RE3_dest_rect[n].top    := y
		RE3_dest_rect[n].bottom := h
		
		w += g_globals.config.textsize
		x += g_globals.config.textsize
		n += 1
	}
	y += g_globals.config.textsize
	h += g_globals.config.textsize 
	x := 0
	w := g_globals.config.textsize
}

x := 0, y := 0, w := 256, h := 256, n := 1
loop, 2
{
	loop, 2
	{
		RE3_rectb[n].left   := x
		RE3_rectb[n].right  := w
		RE3_rectb[n].top    := y
		RE3_rectb[n].bottom := h
		
		w += 256
		x += 256
		n += 1
	}
	y += 256
	h += 256
	x := 0
	w := 256
}

x := 0, y := 0, w := g_globals.config.textsize, h := g_globals.config.textsize, n := 1
loop, 2
{
	loop, 2
	{
		RE3_dest_rectb[n].left   := x
		RE3_dest_rectb[n].right  := w
		RE3_dest_rectb[n].top    := y
		RE3_dest_rectb[n].bottom := h
		
		w += g_globals.config.textsize
		x += g_globals.config.textsize
		n += 1
	}
	y += g_globals.config.textsize
	h += g_globals.config.textsize
	x := 0
	w := g_globals.config.textsize
}

DDBLTFX.dwFillColor := 0xFF00FF00
logerr(IDirect3DDevice3.Hook("DrawPrimitive")) 
logerr(IDirect3DDevice3.Hook("BeginScene"))
logerr(IDirectDraw4.Hook("SetDisplayMode"))
global  pCloseHandle
logerr("Closehandle Hook: " InstallHook("CloseHandle", pCloseHandle, "Kernel32.dll", "CloseHandle"))
g_globals.pCloseHandle := pCloseHandle

g_globals.config.mods ?: InitFileHooks((g_globals.config.mods := "?"))

AltIDirect3DTexture2_Release(p1)
{
	if !TEXTSWAP_DATA.ignore_release 
	{
		for k, v in g_globals.RE3_Textures
		{
			if (v.pt = p1)
				g_globals.RE3_Textures.remove(k)
		}
	}
	return IDirect3DTexture2_Release(p1)	
}

Alt_Lock(p1, p2, p3, p4, p5){
	RE3_surfdesc[] := p3
	return dllcall(IDirectDrawSurface4.lock, uint, p1, uint, p2, uint, p3, uint, p4, uint, p5, uint)		
}
 
Alt_UnLock(p1, p2)
{			
	static prev_area, prev_room, prev_cam, size
	static FindTexture := dllcall("GetProcAddress", ptr, dllcall("GetModuleHandle", str, "peixoto.dll", ptr), astr, "FindTextureInCollection")
	
	if (RE3_surfdesc.dwWidth = 1024)
	{
		patch_size := (RE3_surfdesc.ddpfPixelFormat.dwRGBBitCount=32) ? 1024 : 512
		increment := (256*RE3_surfdesc.lPitch) - patch_size*4
		n := 0
		loop, 4
		{
			loop, 4
			{
				n += 1
				f := dllcall(FindTexture, uint, 256, uint, 256, uint, RE3_surfdesc.ddpfPixelFormat.dwRGBBitCount, uint, RE3_surfdesc.lPitch
										, uint, RE3_surfdesc.lpSurface, ptr, g_textSwap.pDumpArray, uint, g_textSwap.dumps._MaxIndex(), uint, 4
										, uint, g_textSwap.lazycheck, int)
				RE3_surfdesc.lpSurface += patch_size	
				;if f
					;printl("dump" f " on patch" n " cam " numget(g_globals.RE3_cam_add+0, "char") " " g_globals.RE3_Textures[p1].p[f] "<->" g_textSwap.RE3_replacements[F])
				
				if f and (g_globals.RE3_Textures[p1].p[n] != g_textSwap.RE3_replacements[f])  
				{
					blt := dllcall(IDirectDrawSurface.Blt, uint, g_globals.RE3_Textures[p1].r.surface
					, uint, RE3_dest_rect[]+(n-1)*16
					, uint, g_textSwap.RE3_replacements[f]
					, uint, 0
					, uint, DDBLTFAST_NOCOLORKEY | DDBLT_WAIT 
					, uint, DDBLTFX[]
					, uint)
					blt>0 ? g_textSwap.RE3_replacements[f].u := 0 : g_globals.RE3_Textures[p1].p[n] := g_textSwap.RE3_replacements[f] 
					printl("blt" blt ddraw.err[blt . ""] " patch " n " " g_textSwap.RE3_replacements[f])	
				}
				if (f=0) and (g_globals.RE3_Textures[p1].p[n] > 0)
				{
					blt := dllcall(IDirectDrawSurface.Blt, uint, g_globals.RE3_Textures[p1].r.surface
					, uint, RE3_dest_rect[]+(n-1)*16
					, uint, 0
					, uint, 0
					, uint, DDBLT_COLORFILL | DDBLT_WAIT 
					, uint, DDBLTFX[]
					, uint)
					blt>0 ? g_textSwap.RE3_replacements[f].u := 0 : g_globals.RE3_Textures[p1].p[n] := 0 
					printl("cfill" blt ddraw.err[blt . ""] " patch " n " " g_textSwap.RE3_replacements[n])
				}	
			}				
			RE3_surfdesc.lpSurface += increment	
		}
	} 
	else if (RE3_surfdesc.dwWidth = 512)	
	{		
		increment := (256*RE3_surfdesc.lPitch) - 256*2
		n := 0
		loop, 2
		{
			loop, 2
			{
				n += 1
				f := dllcall(FindTexture, uint, 256, uint, 256, uint, RE3_surfdesc.ddpfPixelFormat.dwRGBBitCount, uint, RE3_surfdesc.lPitch
										, uint, RE3_surfdesc.lpSurface, ptr, g_textSwap.pDumpArray, uint, g_textSwap.dumps._MaxIndex(), uint, 4
										, uint, g_textSwap.lazycheck, int)
				RE3_surfdesc.lpSurface += 256	
				;if f
					;printl("dump" f " on patch" n " cam " numget(g_globals.RE3_cam_add+0, "char") " " g_globals.RE3_Textures[p1].p[f] "<->" g_textSwap.RE3_replacements[F])
				
				if f and (g_globals.RE3_Textures[p1].p[n] != g_textSwap.RE3_replacements[f])  
				{
					blt := dllcall(IDirectDrawSurface.Blt, uint, g_globals.RE3_Textures[p1].r.surface
					, uint, RE3_dest_rectb[]+(n-1)*16
					, uint, g_textSwap.RE3_replacements[f]
					, uint, 0
					, uint, DDBLT_WAIT 
					, uint, DDBLTFX[]
					, uint)
					blt>0 ? g_textSwap.RE3_replacements[f].u := 0 : g_globals.RE3_Textures[p1].p[n] := g_textSwap.RE3_replacements[f] 
					printl("blt" blt ddraw.err[blt . ""] " patch " n " " g_textSwap.RE3_replacements[f])					
				}
				if (f=0) and (g_globals.RE3_Textures[p1].p[n] > 0)
				{
					blt := dllcall(IDirectDrawSurface.Blt, uint, g_globals.RE3_Textures[p1].r.surface
					, uint, RE3_dest_rectb[]+(n-1)*16
					, uint, 0
					, uint, 0
					, uint, DDBLT_COLORFILL | DDBLT_WAIT 
					, uint, DDBLTFX[]
					, uint)
					blt>0 ? g_textSwap.RE3_replacements[f].u := 0 : g_globals.RE3_Textures[p1].p[n] := 0 
					printl("cfill" blt ddraw.err[blt . ""] " patch " n " " g_textSwap.RE3_replacements[n])
				}	
			}				
			RE3_surfdesc.lpSurface += increment	
		}
	}	
	return dllcall(IDirectDrawSurface4.Unlock, uint, p1, uint, p2)		
}

AltIDirectDrawSurface4_QueryInterface(p1, p2, p3)
{
	static desc
	desc ?: (desc := struct(ddSurfaceDesc2)).dwSize := desc.size()	
	r := IDirectDrawSurface4_QueryInterface(p1, p2, p3)
	if (StringFromIID(p2) = d3d.IID_IDirect3DTexture2) 
	{
		dllcall(IDirectDrawSurface4.GetSurfaceDesc, uint, p1, uint, desc[])
		patches := (desc.dwWidth=1024) ? 16 : 4
		size    := (desc.dwWidth=1024) ? g_globals.config.textsize*4 : g_globals.config.textsize*2
		r := new SurrogateSurface("A8RGB", (size<<16) | size, True)
		g_globals.RE3_Textures[p1] := {"pt" : numget(p3+0, "ptr"), "r" : r, "p" : []
		                              , "u" : 0}
		;VarSetCapacity(ckey, 8, 0)
		;dllcall(IDirectDrawSurface.SetColorKey, uint, g_globals.RE3_Textures[p1].r.Surface, uint, DDCKEY_SRCBLT, uint, &ckey)
		blt := dllcall(IDirectDrawSurface4.Blt, uint, g_globals.RE3_Textures[p1].r.surface
					, uint, 0
					, uint, 0
					, uint, 0
					, uint, DDBLT_COLORFILL | DDBLT_WAIT 
					, uint, DDBLTFX[]
					, uint)
		loop, % patches
			g_globals.RE3_Textures[p1].p.insert(0)
		g_globals.RE3_Textures_ := {}
		for k, v in g_globals.RE3_Textures
			g_globals.RE3_Textures_[v.pt] := v.r.texture2
		dllcall(IDirectDrawSurface4.GetUniquenessValue, uint, r.Surface4, "uint*", u)
		g_globals.RE3_Textures[p1].u := u
	}
	return r	
}

AltIDirect3DDevice3_DrawPrimitive(p1, p2, p3, p4, p5, p6)
{
	TEXTSWAP_DATA.ignore_release := True
	dllcall(IDirect3DDevice3.GetTexture, uint, p1, uint, 0, "uint*", current)
	current ? dllcall(IDirect3DTexture2.release, uint, current)
	dllcall(IDirect3DDevice3.SetTexture, uint, p1, uint, 4, uint, g_globals.RE3_Textures_[current])
	dllcall(IDirect3DDevice3.SetTexture, uint, p1, uint, 5, uint, g_globals.old_background)
	r := dllcall(IDirect3DDevice3.DrawPrimitive, uint, p1, uint, p2, uint, p3, uint, p4, uint, p5, uint, p6)	
	dllcall(IDirect3DDevice3.SetTexture, uint, p1, uint, 4, uint, 0)
	dllcall(IDirect3DDevice3.SetTexture, uint, p1, uint, 5, uint, 0)
	TEXTSWAP_DATA.ignore_release := False	
	return r	
}

IDirect3DDevice3_BeginScene(p1)
{
	static desc
	desc ?: (desc := struct(ddSurfaceDesc2)).dwSize := desc.size()
	
	/*
	if not g_globals.RE3_room_add
	{
		hwin := g_globals.config.script_hwnd
		WinGetTitle, title, ahk_id %hwin%
		if title is number
		{	
			g_globals.is_gameplay_add   := title - 76
			g_globals.RE3_room_add  := title
			g_globals.RE3_cam_add   := title + 2
			g_globals.RE3_area_add  := title + 5			
		}
	}
	*/
	
	for k, v in g_globals.RE3_Textures
	{
		if dllcall(IDirectDrawSurface4.IsLost, uint, v.r.surface)
		{
			dllcall(IDirectDrawSurface4.Restore, uint, v.r.surface)
			blt := dllcall(IDirectDrawSurface4.Blt, uint, v.r.surface
					, uint, 0
					, uint, 0
					, uint, 0
					, uint, DDBLT_COLORFILL | DDBLT_WAIT 
					, uint, DDBLTFX[]
					, uint)
			for kk, vv in v.p
				vv := 0			
		}	
		dllcall(IDirectDrawSurface4.GetUniquenessValue, uint, k, "uint*", u)
		if (u != v.u)
		{
			Alt_Lock(k, 0, desc[], DDLOCK_READONLY, 0)
			Alt_UnLock(k, 0)
			dllcall(IDirectDrawSurface4.GetUniquenessValue, uint, k,"uint*", u)
			(v.u>0)? v.u:= u
		}
	}	
	return dllcall(IDirect3DDevice3.BeginScene, uint, p1)	
}

AltIDirect3DDevice3_EndScene(p1)
{
	r := dllcall(IDirect3DDevice3.EndScene, uint, p1)		
	if not g_globals.config.TextSwap 
		return r
	
	static clr := 0x000000ff			
	keyevent(g_textSwap.color_switch) ?	clr := cicleColor(clr)
	if keyevent(g_textSwap.switch)
		g_textSwap.search := (g_textSwap.search) & True ? False : True
	TEXTSWAP_DATA.search_enabled := g_textSwap.search
	
	(g_textSwap.search) & True ? RE3browseDevice3Textures2(g_globals.RenderTarget, g_Globals.pIDirectDraw, clr)	
	(g_textSwap.nopopins) ?: TextSwapUpdate2Device3(g_Globals.pIDirectDraw)	
	(g_textSwap.search) & True ? writeOnSurface(g_globals.RenderTarget, "room " g_globals.jpg 
	 , clr, 0, g_textSwap.bltsz+30) 
	;dllcall(g_d3D9_DDI.Flush, uint, D3D9_DDI_HOOKS.hCurrent_Device)		 
	return r
}

Alt_SetDisplayMode(p1, p2, p3, p4, p5, p6)
{
	code := g_globals.RE_shader_code
	ww := p2+0.0, hh := p3+0.0
	logerr("size " ww "x" hh)
	stringreplace, code, code, 640., %ww%
	stringreplace, code, code, 480., %hh%
	g_globals.RE_shader := d3D9_DDI_CreatePixelShader(code, "main")
	isobject(g_globals.RE_shader) ?: logerr(g_globals.RE_shader)
	d3D9_DDI_SetShaderOverride(g_globals.RE_shader)
	return dllcall(IDirectDraw4.SetDisplayMode, uint, p1, uint, p2, uint, p3, uint, p4, uint, p5, uint, p6)
}

Alt_CreateSurface(pIDirectDraw4, pSurfaceDesc, ppSurface, pIUnknown)
{
	static SurfaceDesc 	
	SurfaceDesc ?: SurfaceDesc := ddSurfaceDesc2.clone()		
	SurfaceDesc[] := pSurfaceDesc 
	r := IDirectDraw4_CreateSurface(pIDirectDraw4, pSurfaceDesc, ppSurface, pIUnknown)
	
	if !r and (SurfaceDesc.ddscaps.dwCaps & DDSCAPS_3DDEVICE)
	{
		winget, g_hwin, ID, Resident Evil 3
		logerr(SurfaceDesc.dwWidth "x" SurfaceDesc.dwHeight)
		if (SurfaceDesc.dwWidth & SurfaceDesc.dwHeight)
		{
			code := g_globals.RE_shader_code
			ww := SurfaceDesc.dwWidth+0.0, hh := SurfaceDesc.dwHeight+0.0
			logerr("size " ww "x" hh)
			stringreplace, code, code, 640., %ww%
			stringreplace, code, code, 480., %hh%			
			g_globals.RE_shader := d3D9_DDI_CreatePixelShader(code, "main")
			isobject(g_globals.RE_shader) ?: logerr(g_globals.RE_shader)
			d3D9_DDI_SetShaderOverride(g_globals.RE_shader)	
		}	
		
		g_globals.RE3_Textures  := {}
		g_globals.RE3_main_cache := RE3_cachetextures(g_textSwap.dumps, g_globals.RE3_main_cache)
		dump := struct("DWORD ww; DWORD hh; DWORD bypp; DWORD pData; DWORD samples; BOOL isOptimized; BOOL found")
		g_textSwap.RE3_replacements := []	
		g_textSwap.pDumpArray ? dllcall("VirtualFree", uint, g_textSwap.pDumpArray, uint, 0, uint, (MEM_RELEASE := 0x8000) )
		g_textSwap.pDumpArray := dllcall("VirtualAlloc", ptr, 0, ptr, dump.size() * g_textSwap.dumps._MaxIndex()
													   , uint, 0x00001000 | 0x00002000
													   , uint, (PAGE_READWRITE := 0x04), ptr )	
		dump[] := g_textSwap.pDumpArray		
		for k, v in g_textSwap.dumps
		{
			g_textSwap.RE3_replacements.insert(g_globals.RE3_main_cache[k])
			dump.ww := v.w
			dump.hh := v.h
			dump.bypp := v.bypp
			dump.pData := v.data
			dump.samples := v.samples
			dump.isOptimized := v.optimized
			dump.found := v.found
			dump[] += dump.size()
		}	
		dummy := LoadTexture2(g_Globals.pIDirectDraw, "", "test.dds") 		
	} 				
	return r
}

RE3_cachetextures(tList, oldcache="")
{
	static pLoadData2Surface, desc 
	if not pLoadData2Surface
	{
		pLoadData2Surface := dllcall("GetProcAddress", uint, dllcall("GetModuleHandleW", str, "peixoto.dll", uint)
													 , astr, "LoadData2Surface", uint)												 
		(desc := struct(ddSurfaceDesc)).dwSize := desc.size()	
	}
	if oldcache	{
		for k, v in oldcache
			v ? printl("Releasing cached texture " dllcall(IDirectDrawSurface.Release, uint, v))
	}
	cache := []
	for k, v in tList
	{
		if not instr(fileexist(v.replacement), "A") 		
		{
			cache.insert(0)
			continue
		}	
		zeromem(DDS_HEADER)
		pixelformat := OpenDDS(v.replacement, hFile)		
		desc.dwSize := DDSURFACEDESC.size()
		desc.dwFlags := DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT 
		desc.dwWidth := DDS_HEADER.dwWidth 
		desc.dwHeight := DDS_HEADER.dwHeight		
		desc.ddsCaps.dwCaps := DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREEPLAIN 	
		setPixelFormat(desc, pixelformat)			
		
		r := dllcall(IDirectDraw.CreateSurface, uint, g_globals.pIDirectDraw , uint, desc[]
											  , "ptr*", pSysMem, uint, 0, uint)
		printl("Texture Load SMSurface: "	r " " ddraw.err[r . ""])
		if r {
			cache.insert(0)
			continue
		}

		r := dllcall(IDirectDrawSurface.Lock, uint, pSysMem, uint, 0, uint, desc[], uint, DDLOCK_WRITEONLY, uint, 0, uint)
		printl("Texture Load Lock: " r " " ddraw.err[r . ""])
		if r {
			cache.insert(0)
			continue
		}
				
		pitch := desc.lpitch
		pSurfdata := desc.lpSurface
		hLines := DDS_HEADER.dwHeight		
								 
		if (r:= dllcall(pLoadData2Surface, uint, pSurfdata, uint, hFile, uint, pitch, uint, desc.dwWidth
	                                     , uint, hLines, uint, DDS_HEADER.ddspf.dwRGBBitCount/8))
		{
			printl("Texture Load - Copy " r " handle:" hFile)
			size := desc.dwWidth*DDS_HEADER.ddspf.dwRGBBitCount/8
			loop, % hLines
				dllcall("ReadFile", uint, hFile, uint, pSurfdata + pitch * (A_index-1), uint, size, "uint*", (rd:=0), uint, 0)	
		}
		dllcall("CloseHandle", uint, hFile)						 
			
		r := dllcall(IDirectDrawSurface.UnLock, uint, pSysMem, uint, desc.lpSurface)
		if r {
			cache.insert(0)
			continue
		}
		printl("Texture Load UnLock: " r " " ddraw.err[r . ""])			
		cache.insert(pSysMem)
	}	
	return cache
}

RE3browseDevice3Textures2(pBackbuffer, pddraw, clr = 0x00FFFFFF)
{
	static SurfaceDesc, __rect
	SurfaceDesc ?: SurfaceDesc := struct(ddSurfaceDesc)	
	SurfaceDesc.dwSize := SurfaceDesc.size()
	
	static lRECT, lRECTB, lDDBLTFX, currentindex, DrawRect, current_rect := 1
	if not isobject(lRECT) 
	{
		currentindex := 0
		lDDBLTFX := DDBLTFX.clone()
		lDDBLTFX.dwsize := lDDBLTFX.size()
		lRECT := RECT.clone()
		lRECT.top := 0,	lRECT.left := 0
		lRECT.right := g_textSwap.bltsz, lRECT.bottom := g_textSwap.bltsz	
		lRECTB := RECT.clone()
		lRECBT.top := 0, lRECTB.left := g_textSwap.bltsz+20	
		lRECTB.right := g_textSwap.bltsz*2+20, lRECTB.bottom := g_textSwap.bltsz	
		DrawRect := dllcall("GetProcAddress", uint, g_globals.h_PeixotoDll, astr, "IDirect3DDevice3_DrawRect")		
		__rect := struct("float x; float y; float w; float h")				
	}
	
	GUID_FromString(idd_surface, ddraw.IID_IDirectDrawSurface)
	dllcall(IDirectDrawSurface4.QueryInterface, uint, pBackbuffer, uint, &idd_surface, "uint*", pBack, uint)

	if not (g_textSwap.textures2_entry[] := g_textSwap.textures2.ValueAt(currentindex))
		if not g_textSwap.textures2_entry[] := g_textSwap.textures2.ValueAt((currentindex:=0))
			return
	TEXTSWAP_DATA.curent_texture := g_textSwap.textures2_entry.pTexture
	
	pSurface ?: dllcall(IDirect3DTexture2.QueryInterface, uint, g_textSwap.textures2_entry.pTexture, uint, &idd_surface, "uint*", pSurface, uint)
	d := dllcall(IDirectDrawSurface.GetSurfaceDesc, uint, pSurface, uint, SurfaceDesc[])	
	;logerr(d " " ddraw.err[d . ""] SurfaceDesc.dwWidth)	
				
	if !getkeystate(g_textSwap.quick) 
	{		
		if keyevent(g_textSwap.next) 
			currentindex += 1
		else if keyevent(g_textSwap.prev) 
			currentindex -= 1		
	} else {
		if keyevent(g_textSwap.next) 
			current_rect += 1
		else if keyevent(g_textSwap.prev) 
			current_rect -= 1		
	}
	if keyevent(g_textSwap.dump)
	{
		n := 0
		file := "dump" n ".dds"
		while fileexist(g_textSwap.path "\dumps\" file) {
			n += 1
			file := "dump" n ".dds"
		} 
		pRect := (SurfaceDesc.dwWidth=1024) ? RE3_rect[] :  RE3_rectb[]
		dllcall(IDirect3DTexture2.QueryInterface, uint, g_textSwap.textures2_entry.pTexture, uint, &idd_surface, "uint*", pSurface, uint)	
		RE3dumpSurface(pSurface, g_textSwap.path "\dumps\" file, pRect+(current_rect-1)*rect.size())		
		soundplay, *64
	} 

	n=0
	for k, v in g_globals.RE3_Textures {
		n+=1
		if (g_textSwap.textures2_entry.pTexture = v.pt)
			current := v.r.Surface4
	}
	
	if (currentindex >= n)
		currentindex := 0	
	else if (currentindex < 0 )
		currentindex := n-1	
	if (current_rect > SurfaceDesc.dwWidth*SurfaceDesc.dwWidth/65536)
		current_rect := 1	
	else if (current_rect <= 0 )
		current_rect := SurfaceDesc.dwWidth*SurfaceDesc.dwWidth/65536

	if (SurfaceDesc.dwWidth=1024)
	{
		__rect.x := RE3_rect[current_rect].left/SurfaceDesc.dwWidth
		__rect.y := RE3_rect[current_rect].top/SurfaceDesc.dwHeight
		__rect.w := RE3_rect[current_rect].right/SurfaceDesc.dwWidth
		__rect.h := RE3_rect[current_rect].bottom/SurfaceDesc.dwHeight
		}else if (SurfaceDesc.dwWidth=512) {
		__rect.x := RE3_rectb[current_rect].left/SurfaceDesc.dwWidth
		__rect.y := RE3_rectb[current_rect].top/SurfaceDesc.dwHeight
		__rect.w := RE3_rectb[current_rect].right/SurfaceDesc.dwWidth
		__rect.h := RE3_rectb[current_rect].bottom/SurfaceDesc.dwHeight
	}
		
	d3D9_DDI_RestoreShader()	
	TEXTSWAP_DATA.ignore_release := True
	DEVICE3_RECT.Device3 := g_globals.Device3
	DEVICE3_RECT.Texture := g_textSwap.textures2_entry.pTexture
	dllcall(DrawRect, uint, DEVICE3_RECT[], uint, lRECTB[], uint,__rect[], uint) 
	DEVICE3_RECT.Texture := g_textSwap.textures2_entry.pTexture
    dllcall(DrawRect, uint, DEVICE3_RECT[], uint, lRECT[], uint, 0, uint)
	TEXTSWAP_DATA.ignore_release := False
	d3D9_DDI_SetShaderOverride(g_globals.RE_shader)	
		
	/*
	blt := dllcall(IDirectDrawSurface.Blt, uint, pBack
		, uint, lRECTB[]
		, uint, current
		, uint, 0
		, uint, DDBLTFAST_NOCOLORKEY | DDBLT_WAIT 
		, uint, lDDBLTFX[]
		, uint)		
		*/
		
	r := writeOnSurface(pBack, "texture: " . currentindex "\" n . " patch " . round(current_rect)
	. " " blt " " ddraw.err[blt . ""], clr, 0, g_textSwap.bltsz) + g_textSwap.bltsz
	
	pSurface ? dllcall(IDirectDrawSurface.release, uint, pSurface)			
	dllcall(IDirectDrawSurface.release, uint, pBack)	
	return r  	
}

RE3dumpSurface(pSurface, dest, pRECT)
{
	lrect := struct("rect")
	lrect[] := pRECT
	
	Zeromem(ddSurfaceDesc)	
	ddSurfaceDesc.dwSize := DDSURFACEDESC.size()
	r := dllcall(IDirectDrawSurface.Lock, uint, pSurface, uint, lrect[], uint, ddSurfaceDesc[], uint, DDLOCK_READONLY, uint, 0, uint)
	DllCall("QueryPerformanceCounter", "Int64*", timenow)	
		
	pixelformat := "X1RGB"	
	bytesperpixel := ddSurfaceDesc.ddpfPixelFormat.dwRGBBitCount/8
	
	Zeromem(DDS_HEADER)	
	DDS_HEADER.dwSize := DDS_HEADER.size()
	DDS_HEADER.dwFlags := DDSD_HEIGHT | DDSD_WIDTH |  DDSD_PIXELFORMAT | DDSD_CAPS
		
	DDS_HEADER.dwWidth := lrect.right-lrect.left
	DDS_HEADER.dwHeight := lrect.bottom-lrect.top
	DDS_HEADER.dwPitchOrLinearSize := 256 * bytesperpixel
	
	DDS_HEADER.dwCaps := DDSCAPS_TEXTURE
	DDS_PIXELFORMAT[] := DDS_HEADER.GetAddress("ddspf")
	setFilePixelFormat(pixelformat)	
		
	printl(ddSurfaceDesc.ddpfPixelFormat.dwRGBBitCount " bits format " pixelformat)
	format := A_FormatInteger
	setformat, integer, hex
	printl("alpha :" ddSurfaceDesc.ddpfPixelFormat.dwRGBAlphaBitMask)
	printl("red   :" ddSurfaceDesc.ddpfPixelFormat.dwRBitMask)
	printl("green :" ddSurfaceDesc.ddpfPixelFormat.dwGBitMask)
	printl("blue  :" ddSurfaceDesc.ddpfPixelFormat.dwBBitMask)
	setformat, integer, %format%
	
	file := FileOpen(dest, "w")	
	VarSetCapacity(ddssig, 4)
	for k, v in [0x44, 0x44, 0x53, 0x20]		
		numput(v, &ddssig+A_index-1, "char")
	
	file.RawWrite(&ddssig, 4)
	file.RawWrite(DDS_HEADER[]+0, DDS_HEADER.size())
		
	hlines := DDS_HEADER.dwHeight		
	print(hlines "`n")
	loop, %hLines%
		file.RawWrite(DDSURFACEDESC.lpSurface + (DDSURFACEDESC.lPitch * (A_index - 1))
					 , DDS_HEADER.dwWidth * bytesperpixel)	
	file.close()	
	
	r := dllcall(IDirectDrawSurface.UnLock, uint, pSurface, uint, ddSurfaceDesc.lpSurface)
	print("Dump UnLock" r  ddraw.err[r . ""] "`n")
}

hBMPFromPNGBuffer(file, width, height) {
	;modified SKAN's code ; http://www.autohotkey.com/forum/post-147052.html#147052
	
	; for AutoHotkey Basic users
	; Ptr := A_PtrSize ? "Ptr" : "Uint" , PtrP := A_PtrSize ? "PtrP" : "UIntP"
	
	fileread, Buffer, *c %file%
	
	nSize := StrLen(Buffer) * 2 ;// 2 ; <-- I don't understand why it has to be multiplied by 2
	hData := DllCall("GlobalAlloc", UInt, 2, UInt, nSize, Ptr)
	pData := DllCall("GlobalLock", Ptr, hData , Ptr)
	DllCall( "RtlMoveMemory", Ptr, pData, Ptr,&Buffer, UInt,nSize )
	DllCall( "GlobalUnlock", Ptr, hData )
	DllCall( "ole32\CreateStreamOnHGlobal", Ptr, hData, Int, True, PtrP, pStream )
	DllCall( "LoadLibrary", Str,"gdiplus" )
	VarSetCapacity(si, 16, 0), si := Chr(1)
	DllCall( "gdiplus\GdiplusStartup", PtrP, pToken, Ptr, &si, UInt,0 )
	DllCall( "gdiplus\GdipCreateBitmapFromStream", Ptr, pStream, PtrP, pBitmap )
	DllCall( "gdiplus\GdipCreateHBITMAPFromBitmap", Ptr,pBitmap, PtrP, hBitmap, UInt,0)
	
	hNewBitMap := DllCall("CopyImage"
		  , Ptr, hBitmap
		  , UInt, 0
		  , Int, width
		  , Int, height
		  , UInt, 0x00000008      ;LR_COPYDELETEORG
		  , Ptr) 
	  
	DllCall( "gdiplus\GdipDisposeImage", Ptr, pBitmap )
	DllCall( "gdiplus\GdiplusShutdown", Ptr, pToken )
	DllCall( NumGet(NumGet(1*pStream)+8), Ptr, pStream )
	
	Return hNewBitMap
}

RE3_LoadTexture2(pInterface, pDevice, file_, colorkey = "")
{
	static desc 
	if not desc
		(desc := struct(ddSurfaceDesc)).dwSize := desc.size()	
	
	pixelformat         := "A8RGB"	
	desc.dwFlags        := DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT 
	desc.dwWidth        := 640
	desc.dwHeight       := 480		
	desc.ddsCaps.dwCaps := DDSCAPS_VIDEOMEMORY | DDSCAPS_TEXTURE	
	setPixelFormat(desc, pixelformat)			
	
	r := dllcall(IDirectDraw.CreateSurface, uint, pInterface, uint, desc[]
										  , "ptr*", pSurface, uint, 0, uint)
	printl("Texture Load Surface: "	r " " ddraw.err[r . ""])
	
	desc.dwFlags &= ~DDSD_CKSRCBLT
	desc.ddsCaps.dwCaps := DDSCAPS_SYSTEMMEMORY | DDSCAPS_OFFSCREEPLAIN 
	r := dllcall(IDirectDraw.CreateSurface, uint, pInterface, uint, desc[]
										  , "ptr*", pSysMem, uint, 0, uint)
	printl("Texture Load SMSurface: "	r " " ddraw.err[r . ""])
		
	printl("hBitmap " (hBitmap  := hBMPFromPNGBuffer(file_, 640, 480)))
	printl("DC      " (BitmapDC := dllcall("CreateCompatibleDC", uint, 0, uint)))
	printl("Select  "  dllcall("SelectObject", uint, BitmapDC, uint, hBitmap))
	
	dllcall(IDirectDrawSurface.GetDC, uint, pSysMem,"uint*", pSurDC)
	dllcall("BitBlt", uint, pSurDC, uint, 0, uint, 0, uint, 640, uint, 480, uint, BitmapDC, uint, 0, uint, 0, uint, 0xcc0020)
	dllcall(IDirectDrawSurface.ReleaseDC, uint, pSysMem, uint, pSurDC)
	dllcall("DeleteObject", uint, hBitmap)
	dllcall("DeleteObject", uint, BitmapDC)
	
	if pSysMem {
	r := dllcall(IDirectDrawSurface.Blt, uint, pSurface, uint, 0, uint, pSysMem, uint, 0, uint, DDBLTFAST_NOCOLORKEY, uint, 0, uint)
	printl("Texture Load Blt: " r " " ddraw.err[r . ""])
	dllcall(IDirectDrawSurface.Release, uint, pSysMem)
	}	
		
	VarSetCapacity(pTexture, 4)	
	GUID_FromString(idd_texture, d3d.IID_IDirect3DTexture2)
	r := dllcall(IDirectDrawSurface.QueryInterface, uint, pSurface
				, ptr, &idd_texture, "ptr*", pTexture, uint)
	printl("Texture Load Texture: " r " " ddraw.err[r . ""] " " pTexture)
			
	dllcall(IDirectdrawSurface.release, uint, pSurface)
	return pTexture
}

AltCreateFileA(p1, p2, p3, p4, p5, p6, p7)
{
	file := strget(p1, "CP0")
	if instr(file, ".jpg") 
	{
		(g_globals.old_background) ? dllcall(IDirect3DTexture2.release, uint, g_globals.old_background)
		g_globals.old_background := RE3_LoadTexture2(g_Globals.pIDirectDraw, "", file) 	
		file := g_globals.config.injector_dir "\Patches\ResidentEvil3\Magenta.jpg"
	} 
	VarSetCapacity(stringU, strlen(file)*2)
	strput(file, &stringU, "UTF-16")
	if (r := CreateFileW(&stringU, p2, p3, p4, p5, p6, p7)	)
		g_re3_handles[r] := file
	return r
}

AltCreateFileW(p1, p2, p3, p4, p5, p6, p7)
{
	static block := true 
	file := strget(p1, "UTF-16")
	if instr(file, "zmovie") and block
	{
		block := False
		PlayFMV(file, g_globals.config.FMVscale)
		block := True
		return -1	
	}
	else return CreateFileW(p1, p2, p3, p4, p5, p6, p7)	
}

CloseHandle(hwnd)
{
	g_re3_handles.remove(p1)
	return dllcall(g_globals.pCloseHandle, uint, hwnd)
}

/*
IDirectDrawSurface4_Lock(p1, p2, p3, p4, p5){
	(v := g_manager.SysMem.Value(p1)) ? p1 := v
	return dllcall(IDirectDrawSurface4.lock, uint, p1, uint, p2, uint, p3, uint, p4, uint, p5, uint)	
}

IDirectDrawSurface4_Unlock(p1, p2)
{
	(v := g_manager.SysMem.Value(p1)) ? p1 := v	
	return  dllcall(IDirectDrawSurface4.Unlock, uint, p1, uint, p2)	
}
*/