; <COMPILER: v1.1.15.03>
#persistent
#NoEnv
SendMode Input
SetWorkingDir %A_AhkPath%
GetCommandLineAsList(index = 0)
{
cmds := []
cmd := dllcall("GetCommandLine", str)
VarSetCapacity(argcount, 4)
p_args := dllcall("Shell32.dll\CommandLineToArgvW", str, cmd, ptr, &argcount, ptr)
loop , % numget(argcount, "int")
cmds.insert(strget(numget(p_args+(A_index - 1)*A_ptrsize, "ptr"), "UTF-16"))
if index = 0
return cmds
else if (index > cmds.maxindex()  or  (cmds.maxindex() + 1 + index < 1))
return "_invalid index_"
else if (index > 0)
return cmds[index]
else if (index < 0)
return cmds[cmds.maxindex() + 1 + index]
}
GetCommandLineValueB(switch, value = "")
{
lst := GetCommandLineAsList()
for k, v in lst {
if (v = switch)
value := lst[k+1]
}return value
}
GetCommandLineValue(switch, value = "")
{
lst := GetScriptParamsAsList()
for k, v in lst {
if (v = switch)
value := lst[k+1]
}return value
}
HijackShortCut(lnk, newTarget, abspath = False, cmdline = False)
{
FileGetShortcut, %lnk%, Target, workingdir, args, desc, _Icon, Iconnum, State
if errorlevel
return errorlevel
cmdline ? args := cmdline
if not abspath
newTarget := workingdir "\" newTarget
if (Target = newTarget)
return
FileCreateShortcut, %newTarget%, %lnk%, %workingdir%, "%Target%" %args%, %desc%, %_Icon%, ,%Iconnum%, %state%
return errorlevel
}
GetScriptParamsAsList()
{
global
local params := []
Loop, %0%
params.insert(%A_Index%)
return params
}
GetScriptParams()
{
global
local params := ""
Loop, %0%
params .=  A_Space . """" %A_Index% """"
return params
}
getRunCommand(path = False)
{
path ?: path=%A_scriptdir%
path = "%path%\%A_scriptname%"
if not A_iscompiled
path="%A_AhkPath%" %path%
stringreplace, path, path, % "\\", \, 1
return path
}
RunAsAdmin(condition = False, foo = "temp", args = "")
{
params := GetScriptParams()
if (A_scriptdir = A_temp) {
%foo%()
exitapp
}
if not A_isadmin
{
ShellExecute := A_IsUnicode ? "shell32\ShellExecute" : "shell32\ShellExecuteA"
A_IsCompiled
? DllCall(ShellExecute, uint, 0, str, "RunAs", str, A_ScriptFullPath, str, params, str, A_WorkingDir, int, 1)
: DllCall(ShellExecute, uint, 0, str, "RunAs", str, A_AhkPath, str, """" . A_ScriptFullPath . """" . A_Space . params
, str, A_WorkingDir, int, 1)
ExitApp
}
else
{
if condition
{
filecopy, %A_scriptfullpath%, %A_temp%\%A_scriptname%, 1
run %A_temp%\%A_scriptname% %params% %args%, %A_temp%
exitapp
}
return
}
}
GetCommonPath( csidl )
{
CSIDL_APPDATA = 0x001A
CSIDL_COMMON_APPDATA = 0x0023
CSIDL_COMMON_DOCUMENTS = 0x002e
CSIDL_DESKTOP = 0x0010
CSIDL_FONTS = 0x0014
CSIDL_LOCAL_APPDATA = 0x001C
CSIDL_MYMUSIC = 0x000d
CSIDL_MYPICTURES = 0x0027
CSIDL_PERSONAL = 0x0005
CSIDL_PROGRAM_FILES_COMMON = 0x002b
CSIDL_PROGRAM_FILES = 0x0026
CSIDL_PROGRAMS = 0x0002
CSIDL_RESOURCES = 0x0038
CSIDL_STARTMENU = 0x000b
CSIDL_STARTUP = 0x0007
CSIDL_SYSTEM = 0x0025
CSIDL_WINDOWS = 0x0024
val = % CSIDL_%csidl%
SHGetFolderPath := A_IsUnicode ? "shell32\SHGetFolderPath" : "shell32\SHGetFolderPathA"
VarSetCapacity(fpath, A_IsUnicode ? 260 * 2 : 260)
DllCall(SHGetFolderPath, uint, 0, int, val, uint, 0, int, 0, str, fpath)
return %fpath%
}
MountVirtualDisk(path = "")
{
splitpath, path, , , ext
version := dllcall("GetVersion", uint) & 0xffff
version := version & 0xff "." (version>>8) & 0xff
version += 0
if ( (version > 6.1) or ( (version = 6.1) and (ext = "vhd") ) )
return MountVirtualDiskNative(path)
else
return MountVirtualDiskD(path)
}
MountVirtualDiskD(path = "")
{
setformat, integer, D
if not path
{
try
{
runwait, DTLite.exe -unmount dt`,0
return errorlevel
}
catch
return -1
}
letters = ABCDEFGHJKLMNOPQRSTUVXZ
stringsplit, driveletter, letters, ,
try
{
runwait, DTLite.exe -mount dt`,0`,"%path%"
if errorlevel = -1
return errorlevel
}
catch
return -2
runwait, DTLite.exe -get_letter dt`, 0
driveindex := errorlevel + 1
drive_ := driveletter%driveindex%
return drive_
}
MountVirtualDiskNative(path = "")
{
static h_virtualDisk := False
if not path
{
return dllcall("VirtDisk.dll\DetachVirtualDisk", uint, h_virtualDisk, uint, 0, uint, 0)
h_virtualDisk := false
}
if h_virtualDisk
dllcall("VirtDisk.dll\DetachVirtualDisk", uint, h_virtualDisk, uint, 0, uint, 0)
DriveGet, Before, list
VarSetCapacity(VIRTUAL_STORAGE_TYPE, 20)
numput((VIRTUAL_STORAGE_TYPE_DEVICE_UNKNOWN := 0), VIRTUAL_STORAGE_TYPE, "uint")
VarSetCapacity(h_disk, 4)
err := dllcall("VirtDisk.dll\OpenVirtualDisk", ptr, &VIRTUAL_STORAGE_TYPE, str, Path
, uint, (VIRTUAL_DISK_ACCESS_ATTACH_RO  := 0x00010000) | (VIRTUAL_DISK_ACCESS_GET_INFO := 0x00080000) | (VIRTUAL_DISK_ACCESS_DETACH := 0x00040000)
, uint, 0, uint, 0, ptr, &h_disk, uint)
if err
return 1
VarSetCapacity(ATTACH_VIRTUAL_DISK_PARAMETERS, 8, 0)
numput(1, ATTACH_VIRTUAL_DISK_PARAMETERS, "int")
err := dllcall("VirtDisk.dll\AttachVirtualDisk", uint, numget(h_disk, "uint"), uint, 0
, uint, (ATTACH_VIRTUAL_DISK_FLAG_READ_ONLY := 0x00000001), uint, 0
, ptr, &ATTACH_VIRTUAL_DISK_PARAMETERS, uint, 0)
if err
return 2
else
h_virtualDisk :=  numget(h_disk, "uint")
StartTime := A_TickCount
DriveGet, after, list
while ! (strlen(before) < strlen(after))
{
DriveGet, after, list
if (A_TickCount - StartTime) > 1000
{
msgbox, 52, ,Could not retrieve path of newlly mounted image. Continue waiting?
ifmsgbox, No
return 3
else
StartTime := A_TickCount
}
}
loop, parse, after
if !instr(before, A_loopfield)
return A_loopfield
}
PathRemoveFileSpec(file) {
dllcall("Shlwapi.dll\PathRemoveFileSpecW", str, file, str)
return file
}
rmDirTree(root)
{
loop, %root%\*, 2, 0
rmDirTree(A_LoopFileFullPath)
fileremovedir, %root%, 0
}
deleteLater(file = "")
{
if not file
{
file := A_ScriptFullPath
if instr(A_ScriptFullPath, A_temp) != 1
return -1
}
err := dllcall("MoveFileExW", str, file, uint, 0
, uint, (MOVEFILE_DELAY_UNTIL_REBOOT := 0x4), uint)
if not err
return A_lasterror
else return 0
}
ShellUnzip(arch, dest)
{
names := []
shell := ComObjCreate("Shell.Application")
items := shell.Namespace( arch ).Items()
loop, % items.Count {
item := items.Item(A_index - 1)
name := item.name
names.insert(name)
}
shell.Namespace( dest ).CopyHere( shell.Namespace( arch ).items, 16)
}
GetParentDir() {
try
{
fs := ComObjCreate("Scripting.FileSystemObject")
return fs.GetParentFolderName( fs.GetParentFolderName(A_scriptfullpath) )
}
catch
{
Path = %A_ScriptDir%
Parent := SubStr(Path, 1, InStr(SubStr(Path,1,-1), "\", 0, 0)-1)
return parent
}
}
CreateSimbolicLink(lnk, target, dir=1)
{
if dir {
fileremovedir, %lnk%
filecreatedir, %target%
}
return "Succes= " dllcall("CreateSymbolicLinkW", str, lnk, str, target, uint, dir) " code= " A_lasterror
}
CreateShortCutsFolder(folder, icon, index=0)
{
if fileexist(folder)
{
msgbox,16, ,%folder% already exists
return
}
filecreatedir, %folder%
FileSetAttrib +S, %folder%, 2
ini=%folder%\desktop.ini
IniWrite %icon%, %ini%, .ShellClassInfo, IconFile
IniWrite 0          , %ini%, .ShellClassInfo, IconIndex
IniWrite 0          , %ini%, .ShellClassInfo, ConfirmFileOp
FileSetAttrib +SH, %folder%\desktop.ini, 2
return folder
}
memlib_sound(sound) {
return (sound=1) ? A_windir "\media\Windows Foreground.wav"  : (sound=0) ? A_windir "\media\Windows Ding.wav"
:  A_windir "\media\Windows Critical Stop.wav"
}
get_process_list()
{
process_list := {}
snapshot_handle := dllcall("CreateToolhelp32Snapshot", "int", 0x00000002, int, 0)
varsetcapacity(lppe, 556 , 0),	numput(556, lppe, 0,Int)
success :=  dllcall("Process32First", "Ptr", snapshot_handle, "Ptr", &lppe)
process_list.insert({"name" : StrGet(&lppe + 36, 520, 0), "ID" : NumGet(lppe, 8, "Int")})
offset := (A_ptrsize=4) ? 36 : 44
while (success = 1)
{
varsetcapacity(lppe, 556 , 0),	numput(556, lppe, 0,Int)
success := dllcall("Process32Next", "Ptr", snapshot_handle, "Ptr", &lppe)
process_list.insert({"name" : StrGet(&lppe + offset, 520, 0), "ID" : NumGet(lppe, 8, "Int")})
}
return 	process_list
}
open_process(ProcessID, access = "", InheritHandle = 0)
{
if access =
access := 0x0008 | 0x0010 | 0x0020 |  0x0400
return DllCall("OpenProcess", "Int", access, "Char", InheritHandle, "UInt", ProcessID, "Uint")
}
get_process_handle(process_, access = "")
{
for k, v in get_process_list()
{
if v.name = process_
return open_process(v.ID, access)
}
}
close_process_handle(hProcess){
return dllcall("CloseHandle", "int", hProcess)
}
write_process_memory(hProcess, adress, type_, value)
{
size := {"char": 1, "uchar": 1, "short": 2, "int": 4, "array": value._MaxIndex()
, "float" : 4, "str" : (StrLen(value)+1) * 2}
if (type_ = "array")
{
varsetcapacity(buffer, size[type_], 0)
loop, % value._MaxIndex()
Numput(value[A_index], buffer, A_index - 1, "UChar")
}
else if  (type_ = "str")
{
varsetcapacity(buffer, size[type_], 0)
StrPut(value, &buffer, size[type_], "UTF-16")
}
else
{
varsetcapacity(buffer, size[type_], 0)
Numput(value, buffer, 0, type_)
}
r := dllcall("WriteProcessMemory"
,"Ptr", hProcess
,"Ptr", adress
,"Ptr", &buffer
,"Ptr", size[type_]
,"Ptr", 0
,"uint")
return r
}
read_process_memory(hProcess, adress, type_, arraysize = "")
{
size := {"char": 1, "UChar": 1, "short": 2, "int": 4, "Uint": 4, "Ptr": 4, "array": arraysize
, "float" : 4}
if (type_ = "array")
varsetcapacity(buffer, arraysize, 0)
else
varsetcapacity(buffer, size[type_], 0)
r := dllcall("ReadProcessMemory"
,"Int", hProcess
,"Ptr", adress
,"Ptr", &buffer
,"UInt", size[type_]
,"Int", 0
,"Uint")
if ! r
return
if (type_ = "array")
{
return_value := []
loop, % arraysize
return_value.insert(Numget(buffer,  A_index - 1, "UChar"))
}
else return_value := Numget(buffer,  0, type_)
return return_value
}
read_pointer_sequence(hprocess, baseadress, offsets)
{
pointer := read_process_memory(hprocess, baseadress, "Ptr")
for k, offset in offsets
{
adress := pointer + offset
pointer := read_process_memory(hprocess, adress, "Ptr")
}
return [adress, pointer]
}
class CodeInjection
{
__New(hprocess, addy, newcode)
{
format := A_FormatInteger
setformat, integer, H
this.process_ := hprocess
this.addy := addy
this.newcode := newcode
this.original_code := read_process_memory(hprocess, this.addy, "array", this.newcode._maxIndex())
setformat, integer, %format%
}
_enable()
{
return write_process_memory(this.process_, this.addy, "array", this.newcode)
}
_disable()
{
return write_process_memory(this.process_, this.addy, "array", this.original_code)
}
switch()
{
current_code := read_process_memory(this.process_, this.addy, "array", this.newcode._maxIndex())
for k, v in current_code
fileappend, % v ":" this.original_code[k] ":" this.newcode[k]"`n", *
if arrays_are_equal(current_code, this.original_code)
{
if this._enable()
return memlib_sound(1)
else return memlib_sound(-1)
}
else if arrays_are_equal(current_code, this.newcode)
{
if this._disable()
return memlib_sound(0)
else return memlib_sound(-1)
}
}
__Delete()	{
this._disable()
}
}
VirtualAllocEx(hProcess, mem_size)
{
adress := dllcall("VirtualAllocEx"
,"ptr", hProcess
,"ptr", 0
,"ptr", mem_size
,"uint", 0x00001000 | 0x00002000
,"uint", 0x04
,"ptr")
return adress
}
dllcallEx(h_process, Lib, function, argument)
{
if (Lib = "Kernel32.dll")
procedure := dllcall("Kernel32.dll\GetProcAddress", ptr, dllcall("LoadLibraryW", str, Lib, ptr), astr, function, ptr)
else
procedure := GetProcAddressEx(h_process, Lib, function)
if not procedure
return 1
adress := VirtualAllocEx(h_process, StrLen(argument) * 2)
if not adress
return 2
if not write_process_memory(h_process, adress, "str", argument) {
dllcall("VirtualFreeEx", ptr, h_process, ptr, adress, ptr, 0, uint, 0x8000)
return 3
}
VarSetCapacity(out, StrLen(argument) * 2)
r := dllcall("ReadProcessMemory"
,"Int", h_process
,"Ptr", adress
,"ptr", &out
,"UInt", StrLen(argument) * 2
,"Int", 0
,"Uint")
if ! (hThread := dllcall("CreateRemoteThread"
,ptr, h_process
,ptr, 0
,ptr, 0
,ptr, procedure
,ptr, adress
,uint, 0
,ptr, 0
,ptr) )
{
dllcall("VirtualFreeEx", ptr, h_process, ptr, adress, ptr, StrLen(argument) * 2, uint, 0x4000 | 0x8000)
return 4
} else {
dllcall("WaitForSingleObject", "ptr", hThread, "uint", 0xffffffff)
dllcall("VirtualFreeEx", ptr, h_process, ptr, adress, ptr, 0, uint, 0x8000)
dllcall("CloseHandle", ptr, hThread)
return 0
}
}
GetProcAddressEx(h_process, module, function)
{
this_fucntion_add := dllcall("Kernel32.dll\GetProcAddress", ptr, dllcall("LoadLibraryW", str, module, ptr), astr, function, ptr)
this_module_info  := find_module(module, DllCall("GetCurrentProcessId"))
offset            := this_fucntion_add - this_module_info.BaseAddr
module_info := find_module(module, dllcall("GetProcessId", uint, h_process, uint))
address     := module_info.BaseAddr + offset
return address
}
ReverseInt32bytes(int32)
{
format := A_FormatInteger
setformat, integer, H
stringreplace, int32, int32, 0x, ,
while (strlen(int32) < 8)
int32 := "0" int32
add_ := []
loop, 4
add_.insert("0x" substr(int32, 7 - (A_index - 1)*2, 2))
setformat, integer, %format%
return add_
}
Class CodeCave
{
__New(hprocess, from, code, nops = 0)
{
format := A_FormatInteger
setformat, integer, H
to := VirtualAllocEx(hprocess, code._MaxIndex() + 6 + nops)
if not to
return
this.orginal_code := read_process_memory(hProcess, from, "array", 6 + nops)
this.code := code
this.from := from
this.to := to
this.hprocess := hprocess
adress2go := ReverseInt32bytes(to)
adress2return := ReverseInt32bytes(from + 6 + nops)
this.jump_instruction := [0x68]
loop, 4
this.jump_instruction.insert(adress2go[A_index])
this.jump_instruction.insert(0xc3)
loop, % nops
this.jump_instruction.insert(0x90)
this.jumpback_instruction := [0x68]
loop, 4
this.jumpback_instruction.insert(adress2return[A_index])
this.jumpback_instruction.insert(0xc3)
setformat, integer, %format%
}
_enable()
{
if not write_process_memory(this.hprocess, this.from, "array", this.jump_instruction)
return
for k, v in this.jumpback_instruction
this.code.insert(v)
return write_process_memory(this.hprocess, this.to, "array", this.code)
}
_disable()	{
return write_process_memory(this.hprocess, this.from, "array", this.orginal_code)
}
switch()
{
if arrays_are_equal(read_process_memory(this.hprocess, this.from, "array"
,this.orginal_code._MaxIndex()), this.orginal_code)
{
if this._enable()
return memlib_sound(1)
else return memlib_sound(-1)
}
else if arrays_are_equal(read_process_memory(this.hprocess, this.from, "array"
,this.jump_instruction._MaxIndex()), this.jump_instruction)
{
if this._disable()
return memlib_sound(0)
else return memlib_sound(-1)
}
}
__Delete()	{
this._disable()
return dllcall("VirtualFreeEx", uint, this.hprocess, uint, this.to, uint, 0, uint, (MEM_RELEASE := 0x8000) )
}
}
GetSystemInfo()
{
varsetcapacity(lpSystemInfo, (A_ptrsize=4) ? 36 : 48)
dllcall("GetSystemInfo", "Int", &lpSystemInfo)
MinimumApplicationAddres := numget(lpSystemInfo, 8, "ptr")
MaximumApplicationAddress := numget(lpSystemInfo, 8+A_ptrsize, "ptr")
fileappend, % MinimumApplicationAddres	" " MaximumApplicationAddress "`n", *
return [MinimumApplicationAddres, MaximumApplicationAddress]
}
VirtualQueryEx(hprocess, base_adress)
{
varsetcapacity(MEMORY_BASIC_INFORMATION, (A_ptrsize=4)?28:48)
success := dllcall("VirtualQueryEx"
,"Int", hProcess
,"Int", base_adress
,"Ptr", &MEMORY_BASIC_INFORMATION
,"Int", (A_ptrsize=4)?28:48)
if not success
return False
return [numget(MEMORY_BASIC_INFORMATION, 0, "ptr"), numget(MEMORY_BASIC_INFORMATION, A_ptrsize*2, "int32")
,numget(MEMORY_BASIC_INFORMATION, A_ptrsize*3, "ptr"), numget(MEMORY_BASIC_INFORMATION, (A_ptrsize=4)?20:36, "int32")]
}
find_memory_pages(hprocess)
{
r := GetSystemInfo()
Min := r[1]
Max := r[2]
pages := []
result := True
while result
{
result :=  VirtualQueryEx(hprocess, Min)
if (result[4] && 0x10) and (result[2] && 0x10)
pages.insert({"base_" : result[1], "Alocation" : result[4], "Size" : result[3]})
Min := result[1] + result[3]
}
for k, v in pages
{
Execute := v.Alocation && 0x10
}
return pages
}
arrays_are_equal(a1, a2)
{
format := A_FormatInteger
setformat, integer, H
if not (isobject(a1) or not isobject(a2)) {
setformat, integer, %format%
return 0
}
for k, v in a1
{
if a2[k] is not number {
setformat, integer, %format%
return 0
}
if (v != a2[k]) {
setformat, integer, %format%
return 0
}
}
for k, v in a1
fileappend, % "arrays " v " " a2[k] "`n", *
setformat, integer, %format%
return 1
}
get_process_ID(_process)
{
for k, v in get_process_list() {
if (v.name = _process)
return v.ID
}
}
get_modules_list64(proccessID)
{
hProcess := open_process(proccessID)
dllcall("Psapi.dll\EnumProcessModules", ptr, hProcess, ptr, 0, uint, 0, "uint*", required)
VarSetCapacity(Modules, required)
dllcall("Psapi.dll\EnumProcessModules", ptr, hProcess, ptr, &Modules, uint, required, "uint*", required)
VarSetCapacity(name, 256 * 2)
VarSetCapacity(info, 24)
mods := []
loop, % required/A_ptrsize
{
hModule := numget(&Modules + (A_index - 1) * A_ptrsize, "ptr")
n := dllcall("Psapi.dll\GetModuleBaseNameW", ptr, hProcess, ptr, hModule, ptr, &name, uint, 256 * 2)
i := dllcall("Psapi.dll\GetModuleInformation", ptr, hProcess, ptr, hModule, ptr, &info, uint, 24)
mName := strget(&name+0, "UTF-16")
baseAdd := numget(&info+0, "ptr")
size := numget(&info+A_ptrsize, "uint")
mods.insert({"BaseAddr" : baseAdd, "BaseSize" : size, "Name" : mName})
}
close_process_handle(hProcess)
return mods
}
get_modules_list(proccessID)
{
if (A_ptrsize = 8)
return get_modules_list64(proccessID)
snapshot_handle := 24
while snapshot_handle = 24
snapshot_handle := dllcall("CreateToolhelp32Snapshot"
,"int", (TH32CS_SNAPMODULE := 0x00000008)
,"int", proccessID)
modules := []
varsetcapacity(module_info, 1061 , 0),	numput(1061, module_info, 0, "Int")
success := dllcall("Module32First", "Ptr", snapshot_handle, "Ptr", &module_info)
modules.insert({"BaseAddr"   : numget(module_info, 20, "UInt")
,"BaseSize"   : numget(module_info, 24, "UInt")
,"Name"       : strget(&module_info+32, 512, "UTF-8")})
while success
{
varsetcapacity(module_info, 2061 , 0),	numput(1061, module_info, 0, "Int")
success := dllcall("Module32Next", "Ptr", snapshot_handle, "Ptr", &module_info)
modules.insert({"BaseAddr"   : numget(module_info, 20, "UInt")
,"BaseSize"   : numget(module_info, 24, "UInt")
,"Name"       : strget(&module_info+32, 512, "UTF-8")})
}
return modules
}
find_pages_in_range(hprocess, start, end_)
{
pages := []
for k, v in find_memory_pages(hprocess)
{
if  ((v.base_ >= start) and (v.base_ + v.size <= end_))
{
pages.insert(v)
}
}
return pages
}
read_process_struct(hProcess, byref struct, size, adress)
{
varsetcapacity(bytes_read, A_ptrsize, 0)
r := dllcall("ReadProcessMemory"
,"Ptr", hProcess
,"Ptr", adress
,"Ptr", &struct
,"Ptr", size
,"Ptr", &bytes_read
,"Ptr")
return numget(bytes_read, 0, "int")
}
find_module(name, id_process)
{
for k, v in get_modules_list(id_process)
{
if (name = v.name)
return v
}
}
aobscan(hprocess, id_process, module_name, bytes, dllname = "peixoto.dll", range_ = 1)
{
static sigscan:=0
if not sigscan
{
if not DllCall("LoadLibrary", "Str", dllname, "Ptr")
return "L " . dllname
dllModule := DllCall("GetModuleHandle", "wstr", dllname, "ptr")
if not dllModule
return "G " . dllname
sigscan := dllCall("GetProcAddress", "int", dllModule, "astr", "sigscan", "ptr")
if not sigscan
return "S " . A_lasterror
}
module := find_module(module_name, id_process)
if not module
return "M " module_name
if (range_ = 1)
pages := find_pages_in_range(hprocess, module.BaseAddr, module.BaseAddr + module.BaseSize)
else if (range_ = 0)
pages := find_memory_pages(hprocess)
else if (range_ > 1)
pages := find_pages_in_range(hprocess, range_, 0xffffffff)
if not isobject(pages)
return "P " range_
varsetcapacity(buffer, bytes._maxindex(), 0)
loop, % bytes._MaxIndex()
Numput(bytes[A_index], buffer, A_index - 1, "UChar")
for k, v in pages
{
varsetcapacity(pagemem, v.size)
r := read_process_struct(hProcess, pagemem, v.size, v.base_)
s := dllcall(sigscan
,"ptr", &pagemem, "int", v.size
,"ptr", &buffer, "int", bytes._maxindex())
varsetcapacity(pagemem, 0)
if (s > 0)
return v.base_ + s
}
return
}
CreateIdleProcess(Target, workingdir = "", args = "", nowindow = "", rn="")
{
varsetcapacity(SECURITY_ATTRIBUTES, 8 + A_ptrsize)
varsetcapacity(THREAD_SECURITY_ATTRIBUTES, 8 + A_ptrsize)
varsetcapacity(PROCESS_INFORMATION, 8 + A_ptrsize * 2)
varsetcapacity(STARTUPINFO, 9*4 + 2*2 + 7*A_ptrsize)
numput(9*4 + 2*2 + 7*A_ptrsize, STARTUPINFO, 0 , "uint")
if not workingdir
{
SplitPath, Target, OutFileName, OutDir
if not OutDir
workingdir := A_WorkingDir
else workingdir := OutDir
}
flags := rn ? 0 : (CREATE_SUSPENDED := 0x00000004)
if nowindow
flags |= (CREATE_NO_WINDOW := 0x08000000)
r := dllcall("CreateProcess"
,"ptr", 0
,"str", """" Target """ " args
,"Ptr", &SECURITY_ATTRIBUTES
,"Ptr", &THREAD_SECURITY_ATTRIBUTES
,"uint", 1
,"int", flags
,"Ptr", 0
,"Str", workingdir
,"Ptr", &STARTUPINFO
,"Ptr", &PROCESS_INFORMATION)
if (r = 0)
{
return A_lasterror
}
else
{
pInfo            := {}
pInfo.hProcess   := numget(PROCESS_INFORMATION, 0, "ptr")
pInfo.hThread    := numget(PROCESS_INFORMATION, A_ptrsize, "ptr")
pInfo.Process_id := numget(PROCESS_INFORMATION, A_ptrsize*2, "UInt")
pInfo.Thread_id  := numget(PROCESS_INFORMATION, A_ptrsize*2 + 4, "UInt")
return pInfo
}
}
ResumeProcess(hThread){
return dllcall("ResumeThread", "ptr", hThread, "uint")
}
BlockNewProcess(parent_id, child_list)
{
if not isobject(child_list)
child_list := [child_list]
for k, v in child_list
{
h_app := ""
while not h_app
{
process, exist, %parent_id%
if not errorlevel
return
h_app := get_process_handle(v, (PROCESS_CREATE_THREAD := 0x0002)
| (PROCESS_QUERY_INFORMATION := 0x0400)
| (PROCESS_VM_OPERATION := 0x0008)
| (PROCESS_VM_READ := 0x0010)
| (PROCESS_VM_WRITE := 0x0020))
sleep, 100
}
dllcallEx(h_app, "Kernel32.dll", "ExitProcess", "0")
}
}
memlib_Number2String(num, typ, reverse = False)
{
format := A_FormatInteger
VarSetCapacity(var, 4)
numput(num, var, typ)
setformat, integer, h
string :=
if not reverse
{
loop, 4
string .= numget(var, A_index-1, "uchar") " "
}
else
{
loop, 4
string .= numget(var, 4-A_index, "uchar") " "
}
setformat, integer, %format%
return string
}
memlib_String2ByteArray(string)
{
ret := []
loop, parse, string, %A_space%
{
if instr(A_loopfield, "0x")
field := A_loopfield
else field := "0x" A_loopfield
ret.insert(field + 0)
}
return ret
}
StartDll()
{
if g_.ex_script
{
ahktextdll := dllcall("GetProcAddress", uint, dllcall("GetModuleHandle", str, "AutoHotkey.dll"), astr, "ahktextdll")
id         := g_.proc.Thread_id
dllcall(ahktextdll, Str, "#NoTrayIcon`n" g_.ex_script, Str, g_.cmdstring "^-ThreadID^" id, Str, "", "Cdecl UPTR")
}
}
class Codex
{
__new()
{
if (!g_.svs)
return
if fileexist( (dir := g_.target_dir) "\Codex*.dll")
FileMove, %dir%\winmm.dll, %dir%\_winmm.dll, 1
}
__delete()
{
if fileexist( (dir := g_.target_dir) "\Codex*.dll")
FileMove, %dir%\_winmm.dll, %dir%\winmm.dll, 1
}
}
print(msg = "")
{
static hnd=0
if not hnd
{
target := g_.target
splitpath, target, name, dir
g_.console_icon.h := EnumIcons( (g_.target_icon) ? dir "\" g_.target_icon : g_.target)
DllCall("AllocConsole")
hnd := DllCall("GetStdHandle", "int", -11)
dllcall("SetConsoleTitle", str, name)
dllcall("SetConsoleIcon", uint, g_.console_icon.h)
dllcall("SendMessageW", ptr, dllcall("GetConsoleWindow"), uint, 0x0080, uint, 0, uint, g_.console_icon.h)
dllcall("SendMessageW", ptr, dllcall("GetConsoleWindow"), uint, 0x0080, uint, 1, uint, g_.console_icon.h)
}
return dllcall("WriteConsole", "int", hnd , "ptr", &msg, "int", strlen(msg))
}
GetcmdStringFromFile(File)
{
parent := GetParentDir()
cfg    := {}
cmd    := ""
dirs   := ""
mods   := ""
pid    := DllCall("GetCurrentProcessId")
ini    := new ini(File)
for k, v in ini.listKeys()
{
value := ini.read(v)
if (v = "console")
{
print("Devmode (console=true) can only be set on the main.ini file`n")
continue
}
if not value or value="0" or value="False" or v="Help"
continue
if (value = "True") and ! (Key = "DSR")
cmd .= "^/" v
else cmd .= "^-" v "^" value
}
for k, section in ini.listSections()
{
if (section = "Help")
continue
cmd .= "^-" section "^"
for i, key in ini.listKeys(section)
{
cmd .= key "=" ini.read(key, section) ";"
}
}
target := ini.read("target")
splitpath, target, ,target_dir
stringreplace, cmd, cmd, `%target_dir`%, %target_dir%
cmd .= "^-script_hwnd^" A_scripthwnd
cmd .= "^-error_log^" A_WorkingDir "\error.log"
cmd .= "^-Mydocs^" A_mydocuments
cmd .= "^-injector_dir^" A_WorkingDir
reslist := ""
for k, v in D3D9_EnumDisplayModes()
{
w := v.w,
h := v.h
res := w "x" h
instr(reslist, res) ?: reslist .= res . A_space
if ( ( (w>max_w) or (h>max_h) ) and round(w/h*100) = 133 )
{
max_w := w
max_h := h
}
if ( (w>dsr_w) or (h>dsr_h) )
{
dsr_w := w
dsr_h := h
}
}
dsr := ini.read("DSR")
((dsr = "True") || (dsr = "1")) ? cmd .= "^-DSR^" dsr_w "x" dsr_h
cmd .= "^-rlst^" reslist
cmd .= "^-max_4x3_res^" max_w "x" max_h
cmd .= "^-dsk^" A_screenwidth "x" A_screenheight
loop, HKLM, System\CurrentControlSet\Control\Class, 1, 1
{
if (A_LoopRegName = "UserModeDriverNameWOw") {
regread, driver, HKLM, %A_LoopRegSubkey%, %A_loopRegName%
break
} else if (A_LoopRegName = "UserModeDriverName")
regread, driver, HKLM, %A_LoopRegSubkey%, %A_loopRegName%
}
driver := strsplit(driver, "`n")
for k, v in driver
{
if !v
continue
h := dllcall("LoadLibraryW", str, v)
if ! (OpenAdapter := dllcall("GetProcAddress", uint, h, astr, "OpenAdapter"))
dllcall("FreeLibrary", uint, h)
else
break
}
cmd .= "^-D3D_Driver^" v
stringreplace, cmd, cmd, ^, , 0
stringreplace, cmd, cmd, p?, %parent%, All
stringreplace, cmd, cmd, d?, %A_mydocuments%, All
stringreplace, cmd, cmd, c?, %A_scriptdir%, All
return cmd
}
ParseCommandLine(file="")
{
file ?: file := GetCommandLineValueB("-f")
cmd          := GetCmdStringFromFile( file )
VarSetCapacity(OSVERSIONINFO, 276)
numput(276, &OSVERSIONINFO+0)
dllcall("GetVersionExW", ptr, &OSVERSIONINFO)
os_version    := numget(&OSVERSIONINFO+4, "int") + numget(&OSVERSIONINFO+8, "int")*0.1
cmd           .= "^-os_version^" os_version
OSVERSIONINFO := ""
if isobject( (dev := new ini("main.ini")) )
{
game     := strsplit(file, ".ini")[1]
stringreplace, game, game, %A_workingdir%, ,All
stringreplace, game, game, \, ,All
stringreplace, game, game, Scripts, ,All
stringreplace, game, game, Peixoto, ,All
stringreplace, game, game, Profiles, ,All
stringreplace, game, game, User, ,All
stringreplace, game, game, Dev, ,All
devflags := dev.read(game, "devflags")
stringreplace, devflags, devflags, `", ^, All
stringreplace, devflags, devflags, %A_Space%, ^, All
stringreplace, devflags, devflags, @, %A_Space%, All
while instr(devflags, "^^")
stringreplace, devflags, devflags, ^^, ^, All
cmd .= "^" devflags
}
if getkeystate("ctrl", "p")
{
stringreplace, cmd, cmd, -!, -
stringreplace, cmd, cmd, /!, /
}
if getkeystate("alt", "p")
{
stringreplace, cmd, cmd, -?, -
stringreplace, cmd, cmd, /?, /
}
if getkeystate("shift", "p")
{
stringreplace, cmd, cmd, -#, -
stringreplace, cmd, cmd, /#, /
}
if getkeystate("ins", "p")
{
stringreplace, cmd, cmd, -@, -
stringreplace, cmd, cmd, /@, /
}
_cmd := strsplit(cmd, "^")
cfg  := {}
for k, v in _cmd
{
Key := SubStr(v, 1, 1)
if (Key = "-")
cfg[SubStr(v, 2, strlen(v)-1)] := _cmd[k + 1]
else if (Key = "/")
cfg[SubStr(v, 2, strlen(v)-1)] := True
}
if (cfg.saves = "CODEX")
cfg.saves := "fldrs"
if not cfg.target
quit("No target supplied!")
target := cfg.target
splitpath, target, target_name, dir
cfg.target_dir   := dir
cfg.target_name  := target_name
cmd .= "^-target_dir^" dir
cmd .= "^-target_name^" target_name
cfg.layer := new ini("main.ini").read("ddrawlayer")
if (cfg.layer)
cmd .= "^-layer^1"
cfg.wine  := new ini("main.ini").read("wine")
cfg.dxvkv := new ini("main.ini").read("dxvkv")
if (cfg.wine)
cmd .= "^-wine^" . cfg.wine
if (cfg.dxvkv)
cmd .= "^-dxvkv^" . cfg.dxvkv
cfg.common_path := new ini("main.ini").read("common_path")
if (cfg.common_path)
cmd .= "^-common_path^1"
cfg.cmdstring    := cmd
cfg.console_icon := {"h" : 0, "w" : 0, "pitch" : 0}
return cfg
}
Parsecfg(item)
{
c := {}
for k, v in strsplit(item, ";")
{
split := strsplit(v, "=")
key   := split[1]
val   := split[2]
if not split[2]
{
continue
}
(val = "True")  ? val := True
(val = "False") ? val := False
c[key] := val
}
return c
}
quit(msg)
{
msgbox, 16, , % msg
ExitApp
}
Receive_WM_COPYDATA(wParam, lParam)
{
StringAddress := NumGet(lParam + 2*A_PtrSize)
CopyOfData := StrGet(StringAddress)
if isfunc(CopyOfData)
%CopyOfData%()
return True
}
EnumIcons(Filename, Type=14)
{
hModule := DllCall("LoadLibraryW", "str", Filename)
enumproc := RegisterCallback("EnumIconsCallback","F")
DllCall("EnumResourceNamesW", "uint", hModule, "uint", Type, "uint", enumproc, "uint", hModule)
DllCall("GlobalFree", "uint", enumproc)
DllCall("FreeLibrary", "uint", hModule)
return NumGet(param,4)
}
EnumIconsCallback(hModule, lpszType, lpszName, lParam)
{
critical
static ICONINFO="", BITMAP="", pass=0
pass+=1
ICONINFO ?: VarSetCapacity(ICONINFO, 20)
BITMAP ?: VarSetCapacity(ICONINFO, 28)
hIcon := dllcall("LoadImageW", uint, lParam, "uint", lpszName, int, 1, int, 0, int, 0, uint, 0x00000040)
dllcall("GetIconInfo", uint, hIcon, ptr, &ICONINFO)
dllcall("GetObject", uint, numget(&ICONINFO+16, "uint"), uint, 28, ptr, &BITMAP)
if g_.icon
{
if (g_.icon = pass)
g_.console_icon := {"h" : hIcon, "w" : numget(&BITMAP+4, "uint"), "pitch" : numget(&BITMAP+12, "uint")}
else dllcall("DestroyIcon", uint, hIcon)
return true
}
if (numget(&BITMAP+4, "uint") >= g_.console_icon.w) and (numget(&BITMAP+12, "uint") >= g_.console_icon.pitch)
{
fileappend, updating `n, *
if g_.console_icon.h
{
dllcall("DestroyIcon", uint, g_.console_icon.h)
fileappend, destroying `n, *
}
g_.console_icon := {"h" : hIcon, "w" : numget(&BITMAP+4, "uint"), "pitch" : numget(&BITMAP+12, "uint")}
} else dllcall("DestroyIcon", uint, hIcon)
fileappend, % numget(&BITMAP+4, "uint") " x " numget(&BITMAP+8, "uint") " x " numget(&BITMAP+12, "uint")  "`n" , *
return true
}
FileRemoveLink(lnk)
{
static FILE_ATTRIBUTE_REPARSE_POINT := 1024
attributes := dllcall("GetFileAttributesW", str, "savedat1.dat", uint)
if not attributes & FILE_ATTRIBUTE_REPARSE_POINT
return
FileDelete, %lnk%
}
GetMods(dir)
{
static mods := ""
modslst := []
names   := []
loop, Files, %dir%\*.*, D
{
modslst.insert(A_loopfilefullpath)
names.insert(A_loopfilename)
}
mods := ""
gui, new
gui, +hwndThisWindow
gui, -SysMenu
maxxx := 0
maxhh := 0
hwnds := {}
n_cols := modslst._MaxIndex() > 25 ? 15 : round(Sqrt(modslst._MaxIndex()))
for k, v in names
{
state := instr(current, path "\" v)
if !Mod(k-1, 20)
gui, add, checkbox, ym hwndhwnd gboxes checked%state%, %v%
else gui, add, checkbox, hwndhwnd gboxes checked%state%, %v%
guicontrolget, pos, pos, %hwnd%
if (posx+posw > maxx)
{
maxx  := posx+posw
maxxx := posx + posw + 25
}
if (posy+posh > maxy)
{
maxy  := posy+posh
maxhh := posy + posh + 25
}
hwnds[hwnd] := modslst[k]
}
state := instr(current, "?")
gui, add, button, y%maxhh% x%maxxx% w80 h30, Cancel
gui, add, button, x+5 w80 h30, OK
gui, show
WinWaitClose, ahk_id %ThisWindow%
return mods
boxes:
van := hwnds["Vanilla"]
guicontrolget, state, ,%van%
if (state = 1)
{
for k, v in hwnds
{
guicontrol, ,%k%, 0
guicontrol, disable ,%k%
}
guicontrol, ,%van%, 1
guicontrol, enable ,%van%
}else {
for k, v in hwnds
guicontrol, enable ,%k%
}
return
guiclose:
gui, %ThisWindow%: destroy
exitapp
return
buttonCancel:
gui, %ThisWindow%: destroy
exitapp
return
buttonok:
for k, v in hwnds
{
guicontrolget, state, ,%k%
state ? mods .=	";" v
}
stringreplace, mods, mods, `;, ,
gui, %ThisWindow%: destroy
return
}
D3D9_EnumDisplayModes()
{
VarSetCapacity(SysDir, 261*2)
DllCall("GetSystemDirectoryW", Str, SysDir, uint, 261*2)
hModule         := dllcall("LoadLibraryW", str, SysDir "\D3D9.dll", ptr)
Direct3DCreate9 := dllcall("GetProcAddress", uint, hModule, astr, "Direct3DCreate9", ptr)
if ( (! hModule) or (! Direct3DCreate9) )
return "Failed to get the entry point of the Direct3DCreate9 procedure or get the handle to d3D9.dll " A_lasterror
p_D3D9 := dllcall(Direct3DCreate9, uint, 32)
if (!p_D3D9)
return "Failed to create the Direct3D9 Device " A_lasterror
VarSetCapacity(dm, 16)
mode  := 0
modes := []
while(dllcall(numget(numget(p_D3D9+0, "ptr")+A_PtrSize*7, "ptr"), ptr, p_D3D9, uint, 0, uint, 22, uint, mode, ptr, &dm, uint) = 0)
{
modes.Insert({"w" : numget(&dm, "uint"), "h" : numget(&dm+4, "uint")})
mode += 1
}
dllcall(numget(numget(p_D3D9+0, "ptr")+A_PtrSize*2, "ptr"), ptr, p_D3D9)
return modes
}
ClearNVAPIProfile(cfg)
{
dll := A_ptrsize = 4 ? "peixoto.dll" : "peixoto64.dll"
dllcall("LoadLibraryW", str, dll)
dllcall(dll "\NVIDIA_Set", wstr, cfg.target, uint, 0)
}
Global dsound := {}
dsound.CLSID_DirectSound := "{47d4d946-62e8-11cf-93bc-444553540000}"
dsound.CLSID_DirectSound8 := "{3901cc3f-84b5-4fa4-ba35-aa8172b8a09b}"
dsound.CLSID_DirectSoundCapture := "{b0210780-89cd-11d0-af08-00a0c925cd16}"
dsound.CLSID_DirectSoundCapture8 := "{e4bcac13-7f99-4908-9a8e-74e3bf24b6e1}"
dsound.CLSID_DirectSoundFullDuplex := "{fea4300c-7959-4147-b26a-2377b9e7a91d}"
dsound.DSDEVID_DefaultPlayback := "{def00000-9c6d-47ed-aaf1-4dda8f2b5c03}"
dsound.DSDEVID_DefaultCapture := "{def00001-9c6d-47ed-aaf1-4dda8f2b5c03}"
dsound.DSDEVID_DefaultVoicePlayback := "{def00002-9c6d-47ed-aaf1-4dda8f2b5c03}"
dsound.DSDEVID_DefaultVoiceCapture := "{def00003-9c6d-47ed-aaf1-4dda8f2b5c03}"
dsound.IID_IReferenceClock := "{56a86897-0ad4-11ce-b03a-0020af0ba770}"
dsound.IID_IDirectSound := "{279AFA83-4981-11CE-A521-0020AF0BE560}"
dsound.IID_IDirectSound8 := "{C50A7E93-F395-4834-9EF6-7FA99DE50966}"
dsound.IID_IDirectSoundBuffer := "{279AFA85-4981-11CE-A521-0020AF0BE560}"
dsound.IID_IDirectSoundBuffer8 := "{6825a449-7524-4d82-920f-50e36ab3ab1e}"
dsound.GUID_All_Objects := "{aa114de5-c262-4169-a1c8-23d698cc73b5}"
dsound.IID_IDirectSound3DListener := "{279AFA84-4981-11CE-A521-0020AF0BE560}"
dsound.IID_IDirectSound3DBuffer := "{279AFA86-4981-11CE-A521-0020AF0BE560}"
dsound.IID_IDirectSoundCapture := "{b0210781-89cd-11d0-af08-00a0c925cd16}"
dsound.IID_IDirectSoundCaptureBuffer := "{b0210782-89cd-11d0-af08-00a0c925cd16}"
dsound.IID_IDirectSoundCaptureBuffer8 := "{990df4-dbb-4872-833e-6d303e80aeb6}"
dsound.IID_IDirectSoundNotify := "{b0210783-89cd-11d0-af08-00a0c925cd16}"
dsound.IID_IKsPropertySet := "{31efac30-515c-11d0-a9aa-00aa0061be93}"
dsound.IID_IDirectSoundFXGargle := "{d616f352-d622-11ce-aac5-0020af0b99a3}"
dsound.IID_IDirectSoundFXChorus := "{880842e3-145f-43e6-a934-a71806e50547}"
dsound.IID_IDirectSoundFXFlanger := "{903e9878-2c92-4072-9b2c-ea68f5396783}"
dsound.IID_IDirectSoundFXEcho := "{8bd28edf-50db-4e92-a2bd-445488d1ed42}"
dsound.IID_IDirectSoundFXDistortion := "{8ecf4326-455f-4d8b-bda9-8d5d3e9e3e0b}"
dsound.IID_IDirectSoundFXCompressor := "{4bbd1154-62f6-4e2c-a15c-d3b6c417f7a0}"
dsound.IID_IDirectSoundFXParamEq := "{c03ca9fe-fe90-4204-8078-82334cd177da}"
dsound.IID_IDirectSoundFXI3DL2Reverb := "{4b166a6a-0d66-43f3-80e3-ee6280dee1a4}"
dsound.IID_IDirectSoundFXWavesReverb := "{46858c3a-0dc6-45e3-b760-d4eef16cb325}"
dsound.IID_IDirectSoundCaptureFXAec := "{ad74143d-903d-4ab7-8066-28d363036d65}"
dsound.IID_IDirectSoundCaptureFXNoiseSuppress := "{ed311e41-fbae-4175-9625-cd0854f693ca}"
dsound.IID_IDirectSoundFullDuplex := "{edcb4c7a-daab-4216-a42e-6c50596ddc1d}"
dsound.DS3DALG_NO_VIRTUALIZATION := "{c241333f-1c1b-11d2-94f5-00c04fc28aca}"
dsound.DS3DALG_HRTF_FULL := "{c2413340-1c1b-11d2-94f5-00c04fc28aca}"
dsound.DS3DALG_HRTF_LIGHT := "{c2413342-1c1b-11d2-94f5-00c04fc28aca}"
dsound.GUID_DSFX_STANDARD_GARGLE := "{dafd8210-5711-4b91-9fe3-f75b7ae279bf}"
dsound.GUID_DSFX_STANDARD_CHORUS := "{efe6629c-81f7-4281-bd91-c9d604a95af6}"
dsound.GUID_DSFX_STANDARD_FLANGER := "{efca3d92-dfd8-4672-a603-7420894bad98}"
dsound.GUID_DSFX_STANDARD_ECHO := "{ef3e932c-d40b-4f51-8ccf-3f98f1b29d5d}"
dsound.GUID_DSFX_STANDARD_DISTORTION := "{ef114c90-cd1d-484e-96e5-09cfaf912a21}"
dsound.GUID_DSFX_STANDARD_COMPRESSOR := "{ef011f79-4000-406d-87af-bffb3fc39d57}"
dsound.GUID_DSFX_STANDARD_PARAMEQ := "{120ced89-3bf4-4173-a132-3cb406cf3231}"
dsound.GUID_DSFX_STANDARD_I3DL2REVERB := "{ef985e71-d5c7-42d4-ba4d-2d073e2e96f4}"
dsound.GUID_DSFX_WAVES_REVERB := "{87fc0268-9a55-4360-95aa-004a1d9de26c}"
dsound.GUID_DSCFX_CLASS_AEC := "{BF963D80L-C559-11D0-8A2B-00A0C9255AC1}"
dsound.GUID_DSCFX_MS_AEC := "{cdebb919-379a-488a-8765-f53cfd36de40}"
dsound.GUID_DSCFX_SYSTEM_AEC := "{1c22c56d-9879-4f5b-a389-27996ddc2810}"
dsound.GUID_DSCFX_CLASS_NS := "{e07f903f-62fd-4e60-8cdd-dea7236665b5}"
dsound.GUID_DSCFX_MS_NS := "{11c5c73b-66e9-4ba1-a0ba-e814c6eed92d}"
dsound.GUID_DSCFX_SYSTEM_NS := "{5ab0882e-7274-4516-877d-4eee99ba4fd0}"
dsound.IReferenceClock := {}
dsound.IReferenceClock.name := "IReferenceClock"
dsound.IReferenceClock.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(GetTime)              (THIS_ REFERENCE_TIME *pTime) PURE;
    STDMETHOD(AdviseTime)           (THIS_ REFERENCE_TIME rtBaseTime, REFERENCE_TIME rtStreamTime,                                           HANDLE hEvent, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(AdvisePeriodic)       (THIS_ REFERENCE_TIME rtStartTime, REFERENCE_TIME rtPeriodTime,                                           HANDLE hSemaphore, LPDWORD pdwAdviseCookie) PURE;
    STDMETHOD(Unadvise)             (THIS_ DWORD dwAdviseCookie) PURE;
"
)
dsound.IDirectSound := {}
dsound.IDirectSound.name := "IDirectSound"
dsound.IDirectSound.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakercfg)     (THIS_ LPDWORD pdwSpeakercfg) PURE;
    STDMETHOD(SetSpeakercfg)     (THIS_ DWORD dwSpeakercfg) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
"
)
dsound.IDirectSound8 := {}
dsound.IDirectSound8.name := "IDirectSound8"
dsound.IDirectSound8.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(CreateSoundBuffer)    (THIS_ LPCDSBUFFERDESC pcDSBufferDesc, LPDIRECTSOUNDBUFFER *ppDSBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCAPS pDSCaps) PURE;
    STDMETHOD(DuplicateSoundBuffer) (THIS_ LPDIRECTSOUNDBUFFER pDSBufferOriginal, LPDIRECTSOUNDBUFFER *ppDSBufferDuplicate) PURE;
    STDMETHOD(SetCooperativeLevel)  (THIS_ HWND hwnd, DWORD dwLevel) PURE;
    STDMETHOD(Compact)              (THIS) PURE;
    STDMETHOD(GetSpeakercfg)     (THIS_ LPDWORD pdwSpeakercfg) PURE;
    STDMETHOD(SetSpeakercfg)     (THIS_ DWORD dwSpeakercfg) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
    STDMETHOD(VerifyCertification)  (THIS_ LPDWORD pdwCertified) PURE;
"
)
dsound.IDirectSoundBuffer := {}
dsound.IDirectSoundBuffer.name := "IDirectSoundBuffer"
dsound.IDirectSoundBuffer.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
"
)
dsound.IDirectSoundBuffer8 := {}
dsound.IDirectSoundBuffer8.name := "IDirectSoundBuffer8"
dsound.IDirectSoundBuffer8.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSBCAPS pDSBufferCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCurrentPlayCursor, LPDWORD pdwCurrentWriteCursor) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetVolume)            (THIS_ LPLONG plVolume) PURE;
    STDMETHOD(GetPan)               (THIS_ LPLONG plPan) PURE;
    STDMETHOD(GetFrequency)         (THIS_ LPDWORD pdwFrequency) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUND pDirectSound, LPCDSBUFFERDESC pcDSBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Play)                 (THIS_ DWORD dwReserved1, DWORD dwPriority, DWORD dwFlags) PURE;
    STDMETHOD(SetCurrentPosition)   (THIS_ DWORD dwNewPosition) PURE;
    STDMETHOD(SetFormat)            (THIS_ LPCWAVEFORMATEX pcfxFormat) PURE;
    STDMETHOD(SetVolume)            (THIS_ LONG lVolume) PURE;
    STDMETHOD(SetPan)               (THIS_ LONG lPan) PURE;
    STDMETHOD(SetFrequency)         (THIS_ DWORD dwFrequency) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(Restore)              (THIS) PURE;
    STDMETHOD(SetFX)                (THIS_ DWORD dwEffectsCount, LPDSEFFECTDESC pDSFXDesc, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(AcquireResources)     (THIS_ DWORD dwFlags, DWORD dwEffectsCount, LPDWORD pdwResultCodes) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
"
)
dsound.IDirectSound3DListener := {}
dsound.IDirectSound3DListener.name := "IDirectSound3DListener"
dsound.IDirectSound3DListener.def :=
( 
"
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;
    STDMETHOD(GetAllParameters)         (THIS_ LPDS3DLISTENER pListener) PURE;
    STDMETHOD(GetDistanceFactor)        (THIS_ D3DVALUE* pflDistanceFactor) PURE;
    STDMETHOD(GetDopplerFactor)         (THIS_ D3DVALUE* pflDopplerFactor) PURE;
    STDMETHOD(GetOrientation)           (THIS_ D3DVECTOR* pvOrientFront, D3DVECTOR* pvOrientTop) PURE;
    STDMETHOD(GetPosition)              (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetRolloffFactor)         (THIS_ D3DVALUE* pflRolloffFactor) PURE;
    STDMETHOD(GetVelocity)              (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)         (THIS_ LPCDS3DLISTENER pcListener, DWORD dwApply) PURE;
    STDMETHOD(SetDistanceFactor)        (THIS_ D3DVALUE flDistanceFactor, DWORD dwApply) PURE;
    STDMETHOD(SetDopplerFactor)         (THIS_ D3DVALUE flDopplerFactor, DWORD dwApply) PURE;
    STDMETHOD(SetOrientation)           (THIS_ D3DVALUE xFront, D3DVALUE yFront, D3DVALUE zFront,                                               D3DVALUE xTop, D3DVALUE yTop, D3DVALUE zTop, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetRolloffFactor)         (THIS_ D3DVALUE flRolloffFactor, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)              (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(CommitDeferredSettings)   (THIS) PURE;
"
)
dsound.IDirectSound3DBuffer := {}
dsound.IDirectSound3DBuffer.name := "IDirectSound3DBuffer"
dsound.IDirectSound3DBuffer.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDS3DBUFFER pDs3dBuffer) PURE;
    STDMETHOD(GetConeAngles)        (THIS_ LPDWORD pdwInsideConeAngle, LPDWORD pdwOutsideConeAngle) PURE;
    STDMETHOD(GetConeOrientation)   (THIS_ D3DVECTOR* pvOrientation) PURE;
    STDMETHOD(GetConeOutsideVolume) (THIS_ LPLONG plConeOutsideVolume) PURE;
    STDMETHOD(GetMaxDistance)       (THIS_ D3DVALUE* pflMaxDistance) PURE;
    STDMETHOD(GetMinDistance)       (THIS_ D3DVALUE* pflMinDistance) PURE;
    STDMETHOD(GetMode)              (THIS_ LPDWORD pdwMode) PURE;
    STDMETHOD(GetPosition)          (THIS_ D3DVECTOR* pvPosition) PURE;
    STDMETHOD(GetVelocity)          (THIS_ D3DVECTOR* pvVelocity) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDS3DBUFFER pcDs3dBuffer, DWORD dwApply) PURE;
    STDMETHOD(SetConeAngles)        (THIS_ DWORD dwInsideConeAngle, DWORD dwOutsideConeAngle, DWORD dwApply) PURE;
    STDMETHOD(SetConeOrientation)   (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetConeOutsideVolume) (THIS_ LONG lConeOutsideVolume, DWORD dwApply) PURE;
    STDMETHOD(SetMaxDistance)       (THIS_ D3DVALUE flMaxDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMinDistance)       (THIS_ D3DVALUE flMinDistance, DWORD dwApply) PURE;
    STDMETHOD(SetMode)              (THIS_ DWORD dwMode, DWORD dwApply) PURE;
    STDMETHOD(SetPosition)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
    STDMETHOD(SetVelocity)          (THIS_ D3DVALUE x, D3DVALUE y, D3DVALUE z, DWORD dwApply) PURE;
"
)
dsound.IDirectSoundCapture := {}
dsound.IDirectSoundCapture.name := "IDirectSoundCapture"
dsound.IDirectSoundCapture.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(CreateCaptureBuffer)  (THIS_ LPCDSCBUFFERDESC pcDSCBufferDesc, LPDIRECTSOUNDCAPTUREBUFFER *ppDSCBuffer, LPUNKNOWN pUnkOuter) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCCAPS pDSCCaps) PURE;
    STDMETHOD(Initialize)           (THIS_ LPCGUID pcGuidDevice) PURE;
"
)
dsound.IDirectSoundCaptureBuffer := {}
dsound.IDirectSoundCaptureBuffer.name := "IDirectSoundCaptureBuffer"
dsound.IDirectSoundCaptureBuffer.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
"
)
dsound.IDirectSoundCaptureBuffer8 := {}
dsound.IDirectSoundCaptureBuffer8.name := "IDirectSoundCaptureBuffer8"
dsound.IDirectSoundCaptureBuffer8.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(GetCaps)              (THIS_ LPDSCBCAPS pDSCBCaps) PURE;
    STDMETHOD(GetCurrentPosition)   (THIS_ LPDWORD pdwCapturePosition, LPDWORD pdwReadPosition) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pwfxFormat, DWORD dwSizeAllocated, LPDWORD pdwSizeWritten) PURE;
    STDMETHOD(GetStatus)            (THIS_ LPDWORD pdwStatus) PURE;
    STDMETHOD(Initialize)           (THIS_ LPDIRECTSOUNDCAPTURE pDirectSoundCapture, LPCDSCBUFFERDESC pcDSCBufferDesc) PURE;
    STDMETHOD(Lock)                 (THIS_ DWORD dwOffset, DWORD dwBytes, LPVOID *ppvAudioPtr1, LPDWORD pdwAudioBytes1,                                           LPVOID *ppvAudioPtr2, LPDWORD pdwAudioBytes2, DWORD dwFlags) PURE;
    STDMETHOD(Start)                (THIS_ DWORD dwFlags) PURE;
    STDMETHOD(Stop)                 (THIS) PURE;
    STDMETHOD(Unlock)               (THIS_ LPVOID pvAudioPtr1, DWORD dwAudioBytes1, LPVOID pvAudioPtr2, DWORD dwAudioBytes2) PURE;
    STDMETHOD(GetObjectInPath)      (THIS_ REFGUID rguidObject, DWORD dwIndex, REFGUID rguidInterface, LPVOID *ppObject) PURE;
    STDMETHOD(GetFXStatus)          (DWORD dwFXCount, LPDWORD pdwFXStatus) PURE;
"
)
dsound.IDirectSoundNotify := {}
dsound.IDirectSoundNotify.name := "IDirectSoundNotify"
dsound.IDirectSoundNotify.def :=
( 
"
    STDMETHOD(QueryInterface)           (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)            (THIS) PURE;
    STDMETHOD_(ULONG,Release)           (THIS) PURE;
    STDMETHOD(SetNotificationPositions) (THIS_ DWORD dwPositionNotifies, LPCDSBPOSITIONNOTIFY pcPositionNotifies) PURE;
"
)
dsound.IKsPropertySet := {}
dsound.IKsPropertySet.name := "IKsPropertySet"
dsound.IKsPropertySet.def :=
( 
"
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;
    STDMETHOD(Get)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,                                       LPVOID pPropertyData, ULONG ulDataLength, PULONG pulBytesReturned) PURE;
    STDMETHOD(Set)              (THIS_ REFGUID rguidPropSet, ULONG ulId, LPVOID pInstanceData, ULONG ulInstanceLength,                                       LPVOID pPropertyData, ULONG ulDataLength) PURE;
    STDMETHOD(QuerySupport)     (THIS_ REFGUID rguidPropSet, ULONG ulId, PULONG pulTypeSupport) PURE;
"
)
dsound.IDirectSoundFXGargle := {}
dsound.IDirectSoundFXGargle.name := "IDirectSoundFXGargle"
dsound.IDirectSoundFXGargle.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXGargle pcDsFxGargle) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXGargle pDsFxGargle) PURE;
"
)
dsound.IDirectSoundFXChorus := {}
dsound.IDirectSoundFXChorus.name := "IDirectSoundFXChorus"
dsound.IDirectSoundFXChorus.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXChorus pcDsFxChorus) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXChorus pDsFxChorus) PURE;
"
)
dsound.IDirectSoundFXFlanger := {}
dsound.IDirectSoundFXFlanger.name := "IDirectSoundFXFlanger"
dsound.IDirectSoundFXFlanger.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXFlanger pcDsFxFlanger) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXFlanger pDsFxFlanger) PURE;
"
)
dsound.IDirectSoundFXEcho := {}
dsound.IDirectSoundFXEcho.name := "IDirectSoundFXEcho"
dsound.IDirectSoundFXEcho.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXEcho pcDsFxEcho) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXEcho pDsFxEcho) PURE;
"
)
dsound.IDirectSoundFXDistortion := {}
dsound.IDirectSoundFXDistortion.name := "IDirectSoundFXDistortion"
dsound.IDirectSoundFXDistortion.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXDistortion pcDsFxDistortion) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXDistortion pDsFxDistortion) PURE;
"
)
dsound.IDirectSoundFXCompressor := {}
dsound.IDirectSoundFXCompressor.name := "IDirectSoundFXCompressor"
dsound.IDirectSoundFXCompressor.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXCompressor pcDsFxCompressor) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXCompressor pDsFxCompressor) PURE;
"
)
dsound.IDirectSoundFXParamEq := {}
dsound.IDirectSoundFXParamEq.name := "IDirectSoundFXParamEq"
dsound.IDirectSoundFXParamEq.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXParamEq pcDsFxParamEq) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXParamEq pDsFxParamEq) PURE;
"
)
dsound.IDirectSoundFXI3DL2Reverb := {}
dsound.IDirectSoundFXI3DL2Reverb.name := "IDirectSoundFXI3DL2Reverb"
dsound.IDirectSoundFXI3DL2Reverb.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXI3DL2Reverb pcDsFxI3DL2Reverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXI3DL2Reverb pDsFxI3DL2Reverb) PURE;
    STDMETHOD(SetPreset)            (THIS_ DWORD dwPreset) PURE;
    STDMETHOD(GetPreset)            (THIS_ LPDWORD pdwPreset) PURE;
    STDMETHOD(SetQuality)           (THIS_ LONG lQuality) PURE;
    STDMETHOD(GetQuality)           (THIS_ LONG *plQuality) PURE;
"
)
dsound.IDirectSoundFXWavesReverb := {}
dsound.IDirectSoundFXWavesReverb.name := "IDirectSoundFXWavesReverb"
dsound.IDirectSoundFXWavesReverb.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSFXWavesReverb pcDsFxWavesReverb) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSFXWavesReverb pDsFxWavesReverb) PURE;
"
)
dsound.IDirectSoundCaptureFXAec := {}
dsound.IDirectSoundCaptureFXAec.name := "IDirectSoundCaptureFXAec"
dsound.IDirectSoundCaptureFXAec.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXAec pDscFxAec) PURE;
    STDMETHOD(GetStatus)            (THIS_ PDWORD pdwStatus) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
"
)
dsound.IDirectSoundCaptureFXNoiseSuppress := {}
dsound.IDirectSoundCaptureFXNoiseSuppress.name := "IDirectSoundCaptureFXNoiseSuppress"
dsound.IDirectSoundCaptureFXNoiseSuppress.def :=
( 
"
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;
    STDMETHOD(SetAllParameters)     (THIS_ LPCDSCFXNoiseSuppress pcDscFxNoiseSuppress) PURE;
    STDMETHOD(GetAllParameters)     (THIS_ LPDSCFXNoiseSuppress pDscFxNoiseSuppress) PURE;
    STDMETHOD(Reset)                (THIS) PURE;
"
)
dsound.IDirectSoundFullDuplex := {}
dsound.IDirectSoundFullDuplex.name := "IDirectSoundFullDuplex"
dsound.IDirectSoundFullDuplex.def :=
( 
"
    STDMETHOD(QueryInterface)   (THIS_ REFIID, LPVOID *) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;
    STDMETHOD(Initialize)     (THIS_ LPCGUID pCaptureGuid, LPCGUID pRenderGuid, LPCDSCBUFFERDESC lpDscBufferDesc, LPCDSBUFFERDESC lpDsBufferDesc, HWND hWnd, DWORD dwLevel, LPLPDIRECTSOUNDCAPTUREBUFFER8 lplpDirectSoundCaptureBuffer8, LPLPDIRECTSOUNDBUFFER8 lplpDirectSoundBuffer8) PURE;
"
)
Global DS3D_DEFAULTCONEANGLE := 360
Global DS3D_DEFERRED := 1
Global DS3D_MAXCONEANGLE := 360
Global DS3DMODE_DISABLE := 2
Global DS3DMODE_HEADRELATIVE := 1
Global DS_UNCERTIFIED := 1
Global DSBCAPS_CTRL3D := 16
Global DSBCAPS_CTRLFREQUENCY := 32
Global DSBCAPS_CTRLFX := 512
Global DSBCAPS_CTRLPAN := 64
Global DSBCAPS_CTRLPOSITIONNOTIFY := 256
Global DSBCAPS_CTRLVOLUME := 128
Global DSBCAPS_GETCURRENTPOSITION2 := 65536
Global DSBCAPS_GLOBALFOCUS := 32768
Global DSBCAPS_LOCDEFER := 262144
Global DSBCAPS_LOCHARDWARE := 4
Global DSBCAPS_LOCSOFTWARE := 8
Global DSBCAPS_MUTE3DATMAXDISTANCE := 131072
Global DSBCAPS_PRIMARYBUFFER := 1
Global DSBCAPS_STATIC := 2
Global DSBCAPS_STICKYFOCUS := 16384
Global DSBFREQUENCY_MAX := 100000
Global DSBFREQUENCY_MIN := 100
Global DSBLOCK_ENTIREBUFFER := 2
Global DSBLOCK_FROMWRITECURSOR := 1
Global DSBPAN_RIGHT := 10000
Global DSBPLAY_LOCHARDWARE := 2
Global DSBPLAY_LOCSOFTWARE := 4
Global DSBPLAY_LOOPING := 1
Global DSBPLAY_TERMINATEBY_DISTANCE := 16
Global DSBPLAY_TERMINATEBY_PRIORITY := 32
Global DSBPLAY_TERMINATEBY_TIME := 8
Global DSBPN_OFFSETSTOP := 4294967295
Global DSBSIZE_FX_MIN := 150
Global DSBSIZE_MAX := 268435455
Global DSBSIZE_MIN := 4
Global DSBSTATUS_BUFFERLOST := 2
Global DSBSTATUS_LOCHARDWARE := 8
Global DSBSTATUS_LOCSOFTWARE := 16
Global DSBSTATUS_LOOPING := 4
Global DSBSTATUS_PLAYING := 1
Global DSBSTATUS_TERMINATED := 32
Global DSCAPS_CERTIFIED := 64
Global DSCAPS_CONTINUOUSRATE := 16
Global DSCAPS_EMULDRIVER := 32
Global DSCAPS_PRIMARY16BIT := 8
Global DSCAPS_PRIMARY8BIT := 4
Global DSCAPS_PRIMARYMONO := 1
Global DSCAPS_PRIMARYSTEREO := 2
Global DSCAPS_SECONDARY16BIT := 2048
Global DSCAPS_SECONDARY8BIT := 1024
Global DSCAPS_SECONDARYMONO := 256
Global DSCAPS_SECONDARYSTEREO := 512
Global DSCBCAPS_CTRLFX := 512
Global DSCBCAPS_WAVEMAPPED := 2147483648
Global DSCBLOCK_ENTIREBUFFER := 1
Global DSCBSTART_LOOPING := 1
Global DSCBSTATUS_CAPTURING := 1
Global DSCBSTATUS_LOOPING := 2
Global DSCCAPS_MULTIPLECAPTURE := 1
Global DSCFX_AEC_MODE_FULL_DUPLEX := 2
Global DSCFX_AEC_MODE_HALF_DUPLEX := 1
Global DSCFX_AEC_STATUS_CURRENTLY_CONVERGED := 8
Global DSCFX_AEC_STATUS_HISTORY_CONTINUOUSLY_CONVERGED := 1
Global DSCFX_AEC_STATUS_HISTORY_PREVIOUSLY_DIVERGED := 2
Global DSFX_I3DL2REVERB_QUALITY_DEFAULT := 2
Global DSFX_I3DL2REVERB_QUALITY_MAX := 3
Global DSFX_I3DL2REVERB_REFLECTIONS_MAX := 1000
Global DSFX_I3DL2REVERB_REVERB_MAX := 2000
Global DSFXCHORUS_PHASE_180 := 4
Global DSFXCHORUS_PHASE_90 := 3
Global DSFXCHORUS_PHASE_MAX := 4
Global DSFXCHORUS_PHASE_NEG_90 := 1
Global DSFXCHORUS_PHASE_ZERO := 2
Global DSFXCHORUS_WAVE_SIN := 1
Global DSFXECHO_PANDELAY_MAX := 1
Global DSFXFLANGER_PHASE_180 := 4
Global DSFXFLANGER_PHASE_90 := 3
Global DSFXFLANGER_PHASE_MAX := 4
Global DSFXFLANGER_PHASE_NEG_90 := 1
Global DSFXFLANGER_PHASE_ZERO := 2
Global DSFXFLANGER_WAVE_SIN := 1
Global DSFXGARGLE_RATEHZ_MAX := 1000
Global DSFXGARGLE_RATEHZ_MIN := 1
Global DSFXGARGLE_WAVE_SQUARE := 1
Global DSSCL_EXCLUSIVE := 3
Global DSSCL_NORMAL := 1
Global DSSCL_PRIORITY := 2
Global DSSCL_WRITEPRIMARY := 4
Global DSSPEAKER_5POINT1 := 6
Global DSSPEAKER_7POINT1 := 7
Global DSSPEAKER_7POINT1_SURROUND := 8
Global DSSPEAKER_GEOMETRY_MAX := 180
Global DSSPEAKER_GEOMETRY_MIN := 5
Global DSSPEAKER_GEOMETRY_NARROW := 10
Global DSSPEAKER_GEOMETRY_WIDE := 20
Global DSSPEAKER_HEADPHONE := 1
Global DSSPEAKER_MONO := 2
Global DSSPEAKER_QUAD := 3
Global DSSPEAKER_STEREO := 4
Global DSSPEAKER_SURROUND := 5
Global KSPROPERTY_SUPPORT_GET := 1
Global KSPROPERTY_SUPPORT_SET := 2
dsound.err := {}
dsound.err[2289565706 . ""] := "DSERR_ALLOCATED"
dsound.err[2289565826 . ""] := "DSERR_ALREADYINITIALIZED"
dsound.err[2289565796 . ""] := "DSERR_BADFORMAT"
dsound.err[2289565906 . ""] := "DSERR_BADSENDBUFFERGUID"
dsound.err[2289565846 . ""] := "DSERR_BUFFERLOST"
dsound.err[2289565876 . ""] := "DSERR_BUFFERTOOSMALL"
dsound.err[2289565726 . ""] := "DSERR_CONTROLUNAVAIL"
dsound.err[2289565886 . ""] := "DSERR_DS8_REQUIRED"
dsound.err[2289565916 . ""] := "DSERR_FXUNAVAILABLE"
dsound.err[2289565746 . ""] := "DSERR_INVALIDCALL"
dsound.err[2289565816 . ""] := "DSERR_NODRIVER"
dsound.err[2289570145 . ""] := "DSERR_OBJECTNOTFOUND"
dsound.err[2289565856 . ""] := "DSERR_OTHERAPPHASPRIO"
dsound.err[2289565766 . ""] := "DSERR_PRIOLEVELNEEDED"
dsound.err[2289565896 . ""] := "DSERR_SENDLOOP"
dsound.err[2289565866 . ""] := "DSERR_UNINITIALIZED"
Global DSERR_ALLOCATED := 2289565706
Global DSERR_ALREADYINITIALIZED := 2289565826
Global DSERR_BADFORMAT := 2289565796
Global DSERR_BADSENDBUFFERGUID := 2289565906
Global DSERR_BUFFERLOST := 2289565846
Global DSERR_BUFFERTOOSMALL := 2289565876
Global DSERR_CONTROLUNAVAIL := 2289565726
Global DSERR_DS8_REQUIRED := 2289565886
Global DSERR_FXUNAVAILABLE := 2289565916
Global DSERR_INVALIDCALL := 2289565746
Global DSERR_NODRIVER := 2289565816
Global DSERR_OBJECTNOTFOUND := 2289570145
Global DSERR_OTHERAPPHASPRIO := 2289565856
Global DSERR_PRIOLEVELNEEDED := 2289565766
Global DSERR_SENDLOOP := 2289565896
Global DSERR_UNINITIALIZED := 2289565866
dsound.err[2147942487 . ""] := "DSERR_INVALIDPARAMS"
dsound.err[0 . ""] := "DSERR_OK"
global WAVE_FORMAT_ADPCM := 0x0002
global WAVE_FORMAT_PCM := 0x0001
global WAVEFORMATEX := Struct("WORD wFormatTag, WORD nChannels, DWORD nSamplesPerSec, DWORD nAvgBytesPerSec, WORD nBlockAlign,"
. "WORD wBitsPerSample, WORD cbSize")
global DSBUFFERDESC := Struct("DWORD dwSize; DWORD dwFlags; DWORD dwBufferBytes; DWORD dwReserved; ptr lpwfxFormat")
global DSBUFFERDESC8 := Struct("DWORD dwSize; DWORD dwFlags; DWORD dwBufferBytes; DWORD dwReserved; ptr lpwfxFormat; GUID guid3DAlgorithm")
global DSBCAPS := Struct("DWORD dwSize, DWORD dwFlags, DWORD dwBufferBytes, DWORD dwUnlockTransferRate, DWORD dwPlayCpuOverhead")
global WAV_FILE_HEADER :=
(
"
DWORD ChunkID;
DWORD ChunkSize;
DWORD Format;
DWORD Subchunk1ID;
DWORD Subchunk1Size;
WORD AudioFormat;
WORD NumChannels;
DWORD SampleRate;
DWORD ByteRate;
WORD BlockAlign;
WORD BitsPerSample;        
DWORD Subchunk2ID;
DWORD Subchunk2Size;
"
)
global WAV_FILE_HEADER := Struct(WAV_FILE_HEADER)
global IDirectSound:=0, IDirectSoundBuffer:=0, IDirectSound8:=0, IDirectSoundBuffer8:=0, IKsPropertySet:=0,IDirectSound3DBuffer:=0
global _DSBUFFERDESC := struct(DSBUFFERDESC)
LoadWAV(file_, formatcheck = True, fcs = False)
{
plock:=0, plocksize:=0
file := FileOpen(file_, "r")
VarSetCapacity(data, file.Length)
file.RawRead(data, file.Length)
file.close()
loop, % file.Length
{
if strget(&data + A_index, 3, "CP0") = "fmt"
{
index := A_index + 8
break
}
}
if not index
return "File format must be .wav (PCM)"
wav := struct(WAVEFORMATEX)
dllcall("RtlMoveMemory", ptr, wav[], ptr, &data + index, int, sizeof(WAVEFORMATEX))
if 	wav.wFormatTag = 1
wav.wFormatTag := WAVE_FORMAT_PCM
else
if formatcheck
return "WAV file must be on PCM format"
loop, % file.Length
{
if strget(&data + A_index, 4,"CP0") = "data"
{
index := A_index
break
}
}
data_size := numget(&data + index + 4, "int")
VarSetCapacity(wave_data, data_size)
dllcall("RtlMoveMemory", ptr, &wave_data, ptr, &data + index + 8, int, data_size)
(D := struct(DSBUFFERDESC8)).dwSize := sizeof(DSBUFFERDESC8)
D.dwFlags       := DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_LOCSOFTWARE
D.dwFlags       := DSBCAPS_CTRLFX
D.dwBufferBytes := data_size
D.lpwfxFormat   := wav[]
fcs ? D.dwFlags |= (DSBCAPS_STICKYFOCUS | DSBCAPS_GLOBALFOCUS )
buff := 0
r := dllcall(IDirectSound8.CreateSoundBuffer, uint, IDirectSound8.p, uint, D[], "uint*", buff, uint, 0, uint)
if r
return r  " CreateSoundBuffer " dsound.err[r . ""]
sndbuff := new ComInterfaceWrapper(dsound.IDirectSoundBuffer, buff, True)
r := dllcall(sndbuff.Lock, uint, sndbuff.p, uint, 0, uint, data_size, "uint*", plock
, "uint*", plocksize, uint, 0, uint, 0, uint, DSBLOCK_ENTIREBUFFER, uint)
if r
return r  " Lock " dsound.err[r . ""]
dllcall("RtlMoveMemory", ptr, plock, ptr, &wave_data, int, data_size)
r := dllcall(sndbuff.UnLock, uint, sndbuff.p, uint, plock, int, data_size, uint, 0, uint, 0, uint)
if r
return r  " Unlock " dsound.err[r . ""]
wav := ""
wave_data := ""
return sndbuff
}
LoadRAWSoundData(byref PMEM, file_)
{
file := FileOpen(file_, "r")
file.RawRead(WAV_FILE_HEADER[], WAV_FILE_HEADER.size())
PMEM := dllcall("VirtualAlloc", uint, 0, uint, WAV_FILE_HEADER.Subchunk2Size, Int, 0x00001000
, uint, 0x04 )
file.RawRead(PMEM+0, WAV_FILE_HEADER.Subchunk2Size)
file.close()
return WAV_FILE_HEADER.Subchunk2Size
}
DumpSndBuffer(pSndBuff, locksize, file)
{
plock:=0, plocksize:=0, size:=0, writen:=0
r := dllcall(IDirectSoundBuffer.GetFormat, uint, pSndBuff, uint, 0, uint, 0, "uint*", size, uint)
print("GetBufferSize " r "-" dsound.err[r . ""] "size: "  size "`n")
varsetcapacity(wave_format, size)
r := dllcall(IDirectSoundBuffer.GetFormat, uint, pSndBuff, uint, &wave_format, uint, size, "uint*", writen, uint)
print("GetBufferFormat " r "-" dsound.err[r . ""] "`n")
WAVEFORMATEX[] := &wave_format
r := dllcall(IDirectSoundBuffer.Lock, uint, pSndBuff, uint, 0, uint, locksize, "uint*", plock
, "uint*", plocksize, uint, 0, uint, 0, uint, DSBLOCK_ENTIREBUFFER, uint)
print("Lock " r "-" dsound.err[r . ""] "`n")
WAV_FILE_HEADER.ChunkID       := 1179011410
WAV_FILE_HEADER.ChunkSize     := plocksize + WAV_FILE_HEADER.size() - 8
WAV_FILE_HEADER.Format        := 1163280727
WAV_FILE_HEADER.Subchunk1ID   := 544501094
WAV_FILE_HEADER.Subchunk1Size := 16
WAV_FILE_HEADER.AudioFormat   := 1
WAV_FILE_HEADER.NumChannels   := WAVEFORMATEX.nChannels
WAV_FILE_HEADER.SampleRate    := WAVEFORMATEX.nSamplesPerSec
WAV_FILE_HEADER.ByteRate      := WAVEFORMATEX.nAvgBytesPerSec
WAV_FILE_HEADER.BlockAlign    := WAVEFORMATEX.nBlockAlign
WAV_FILE_HEADER.BitsPerSample := WAVEFORMATEX.wBitsPerSample
WAV_FILE_HEADER.Subchunk2ID   := 1635017060
WAV_FILE_HEADER.Subchunk2Size := plocksize
f := FileOpen(file, "w")
f.RawWrite(WAV_FILE_HEADER[], WAV_FILE_HEADER.size())
f.RawWrite(plock+0, plocksize)
f.close()
r := dllcall(IDirectSoundBuffer.UnLock, uint, pSndBuff, uint, plock, int, data_size, uint, 0, uint, 0, uint)
print("dump UnLock " r "-" dsound.err[r . ""] "`n")
}
GetDirectSound(hwin = "")
{
dllcall("Ole32.dll\CoInitialize", ptr, 0)
DS:=0, pPrim:=0, pSndbuff:=0
if ! (DSCreate := dllcall("GetProcAddress", "int", dllcall("LoadLibrary", "str", "dsound.dll"), "astr", "DirectSoundCreate"))
return "Failed to load or get the entrypoint(dsound.dll) " A_lasterror
r := dllcall(DSCreate, uint, 0, "uint*", DS, uint, 0, Uint)
if r
return "Failed to create the IDirectSound interface " r  " - " dsound.err[r . ""]
else IDirectSound := new ComInterfaceWrapper(dsound.IDirectSound, DS, True)
r :=  dllcall(IDirectSound.SetCooperativeLevel, uint, IDirectSound.p, uint, hwin ? hwin : A_scripthwnd, uint, DSSCL_NORMAL, uint)
if r
return "Failed to set the DirectSound cooperative level " r  " - " dsound.err[r . ""]
DSBUFFERDESC.dwSize        := sizeof(DSBUFFERDESC)
DSBUFFERDESC.dwFlags       := DSBCAPS_PRIMARYBUFFER
DSBUFFERDESC.dwBufferBytes := 0
DSBUFFERDESC.lpwfxFormat   := 0
r := dllcall(IDirectSound.CreateSoundBuffer, uint, IDirectSound.p, uint, DSBUFFERDESC[], "uint*", pPrim, uint, 0, uint)
if r
return "Failed to create the IDirectSoundBuffer interface " r  " - " dsound.err[r . ""]
DSBUFFERDESC.dwSize        := sizeof(DSBUFFERDESC)
DSBUFFERDESC.dwFlags       := DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_LOCSOFTWARE | DSBCAPS_CTRL3D
DSBUFFERDESC.dwBufferBytes := 33396048
DSBUFFERDESC.lpwfxFormat   := WAVEFORMATEX[]
WAVEFORMATEX.wFormatTag      := 1
WAVEFORMATEX.nChannels       := 2
WAVEFORMATEX.nSamplesPerSec  := 44100
WAVEFORMATEX.nAvgBytesPerSec := 176400
WAVEFORMATEX.nBlockAlign     := 4
WAVEFORMATEX.wBitsPerSample  := 16
WAVEFORMATEX.cbSize          := 0
r := dllcall(IDirectSound.CreateSoundBuffer, uint, IDirectSound.p, uint, DSBUFFERDESC[], "uint*", pSndbuff, uint, 0, uint)
if r
return "Failed to create the IDirectSoundBuffer interface " r  " - " dsound.err[r . ""]
IDirectSoundBuffer := new ComInterfaceWrapper(dsound.IDirectSoundBuffer, pSndbuff, True)
GUID_FromString(iid, dsound.IID_IKsPropertySet)
r := dllcall(IDirectSoundBuffer.QueryInterface, uint, IDirectSoundBuffer.p, uint, &iid, "uint*", pIKs:=0)
if r
return "Failed to create the IKsPropertySet interface " r  " - " dsound.IID_IKsPropertySet " " dsound.err[r . ""]
IKsPropertySet := new ComInterfaceWrapper(dsound.IKsPropertySet, pIKs, True)
GUID_FromString(iid, dsound.IID_IDirectSound3DBuffer)
r := dllcall(IDirectSoundBuffer.QueryInterface, uint, IDirectSoundBuffer.p, uint, &iid, "uint*", p3D:=0)
if r
return "Failed to create the IDirectSound3DBuffer interface " r  " - " dsound.IID_IKsPropertySet " " dsound.err[r . ""]
IDirectSound3DBuffer := new ComInterfaceWrapper(dsound.IDirectSound3DBuffer, p3D, True)
return "Succeeded to create the DirectSound interfaces"
}
GetDirectSound8(hwin = "")
{
dllcall("Ole32.dll\CoInitialize", ptr, 0)
DS:=0, pPrim:=0
if ! (DSCreate := dllcall("GetProcAddress", "int", dllcall("LoadLibrary", "str", "dsound.dll"), "astr", "DirectSoundCreate8"))
return "Failed to load or get the entrypoint(dsound.dll) " A_lasterror
r := dllcall(DSCreate, uint, 0, "uint*", DS, uint, 0, Uint)
if r
return "Failed to create the IDirectSound8 interface " r  " - " dsound.err[r . ""]
else IDirectSound8 := new ComInterfaceWrapper(dsound.IDirectSound8, DS, True)
r :=  dllcall(IDirectSound8.SetCooperativeLevel, uint, IDirectSound8.p, uint, hwin ? hwin : A_scripthwnd, uint, DSSCL_PRIORITY, uint)
if r
return "Failed to set the DirectSound cooperative level " r  " - " dsound.err[r . ""]
DSBUFFERDESC8.dwSize        := sizeof(DSBUFFERDESC8)
DSBUFFERDESC8.dwFlags       := DSBCAPS_PRIMARYBUFFER
DSBUFFERDESC8.dwBufferBytes := 0
DSBUFFERDESC8.lpwfxFormat   := 0
r := dllcall(IDirectSound8.CreateSoundBuffer, uint, IDirectSound8.p, uint, DSBUFFERDESC8[], "uint*", pPrim, uint, 0, uint)
if r
return "Failed to create the IDirectSoundBuffer8 interface " r  " - " dsound.err[r . ""]
else IDirectSoundBuffer8 := new ComInterfaceWrapper(dsound.IDirectSoundBuffer8, pPrim, True)
return "Succeeded to create the DirectSound8 interfaces"
}
sizeof(_TYPE_,parent_offset=0,ByRef _align_total_=0){
static _types__:="
  (LTrim Join
    ,ATOM:2,LANGID:2,WCHAR:2,WORD:2,PTR:" A_PtrSize ",UPTR:" A_PtrSize ",SHORT:2,USHORT:2,INT:4,UINT:4,INT64:8,UINT64:8,DOUBLE:8,FLOAT:4,CHAR:1,UCHAR:1,__int64:8
    ,TBYTE:" (A_IsUnicode?2:1) ",TCHAR:" (A_IsUnicode?2:1) ",HALF_PTR:" (A_PtrSize=8?4:2) ",UHALF_PTR:" (A_PtrSize=8?4:2) ",INT32:4,LONG:4,LONG32:4,LONGLONG:8
    ,LONG64:8,USN:8,HFILE:4,HRESULT:4,INT_PTR:" A_PtrSize ",LONG_PTR:" A_PtrSize ",POINTER_64:" A_PtrSize ",POINTER_SIGNED:" A_PtrSize "
    ,BOOL:4,SSIZE_T:" A_PtrSize ",WPARAM:" A_PtrSize ",BOOLEAN:1,BYTE:1,COLORREF:4,DWORD:4,DWORD32:4,LCID:4,LCTYPE:4,LGRPID:4,LRESULT:4,PBOOL:" A_PtrSize "
    ,PBOOLEAN:" A_PtrSize ",PBYTE:" A_PtrSize ",PCHAR:" A_PtrSize ",PCSTR:" A_PtrSize ",PCTSTR:" A_PtrSize ",PCWSTR:" A_PtrSize ",PDWORD:" A_PtrSize "
    ,PDWORDLONG:" A_PtrSize ",PDWORD_PTR:" A_PtrSize ",PDWORD32:" A_PtrSize ",PDWORD64:" A_PtrSize ",PFLOAT:" A_PtrSize ",PHALF_PTR:" A_PtrSize "
    ,UINT32:4,ULONG:4,ULONG32:4,DWORDLONG:8,DWORD64:8,ULONGLONG:8,ULONG64:8,DWORD_PTR:" A_PtrSize ",HACCEL:" A_PtrSize ",HANDLE:" A_PtrSize "
     ,HBITMAP:" A_PtrSize ",HBRUSH:" A_PtrSize ",HCOLORSPACE:" A_PtrSize ",HCONV:" A_PtrSize ",HCONVLIST:" A_PtrSize ",HCURSOR:" A_PtrSize ",HDC:" A_PtrSize "
     ,HDDEDATA:" A_PtrSize ",HDESK:" A_PtrSize ",HDROP:" A_PtrSize ",HDWP:" A_PtrSize ",HENHMETAFILE:" A_PtrSize ",HFONT:" A_PtrSize ",USAGE:" 2 "
)"
static _types_:=_types__ "
  (LTrim Join
     ,HGDIOBJ:" A_PtrSize ",HGLOBAL:" A_PtrSize ",HHOOK:" A_PtrSize ",HICON:" A_PtrSize ",HINSTANCE:" A_PtrSize ",HKEY:" A_PtrSize ",HKL:" A_PtrSize "
     ,HLOCAL:" A_PtrSize ",HMENU:" A_PtrSize ",HMETAFILE:" A_PtrSize ",HMODULE:" A_PtrSize ",HMONITOR:" A_PtrSize ",HPALETTE:" A_PtrSize ",HPEN:" A_PtrSize "
     ,HRGN:" A_PtrSize ",HRSRC:" A_PtrSize ",HSZ:" A_PtrSize ",HWINSTA:" A_PtrSize ",HWND:" A_PtrSize ",LPARAM:" A_PtrSize ",LPBOOL:" A_PtrSize ",LPBYTE:" A_PtrSize "
     ,LPCOLORREF:" A_PtrSize ",LPCSTR:" A_PtrSize ",LPCTSTR:" A_PtrSize ",LPCVOID:" A_PtrSize ",LPCWSTR:" A_PtrSize ",LPDWORD:" A_PtrSize ",LPHANDLE:" A_PtrSize "
     ,LPINT:" A_PtrSize ",LPLONG:" A_PtrSize ",LPSTR:" A_PtrSize ",LPTSTR:" A_PtrSize ",LPVOID:" A_PtrSize ",LPWORD:" A_PtrSize ",LPWSTR:" A_PtrSize "
     ,PHANDLE:" A_PtrSize ",PHKEY:" A_PtrSize ",PINT:" A_PtrSize ",PINT_PTR:" A_PtrSize ",PINT32:" A_PtrSize ",PINT64:" A_PtrSize ",PLCID:" A_PtrSize "
     ,PLONG:" A_PtrSize ",PLONGLONG:" A_PtrSize ",PLONG_PTR:" A_PtrSize ",PLONG32:" A_PtrSize ",PLONG64:" A_PtrSize ",POINTER_32:" A_PtrSize "
     ,POINTER_UNSIGNED:" A_PtrSize ",PSHORT:" A_PtrSize ",PSIZE_T:" A_PtrSize ",PSSIZE_T:" A_PtrSize ",PSTR:" A_PtrSize ",PTBYTE:" A_PtrSize "
     ,PTCHAR:" A_PtrSize ",PTSTR:" A_PtrSize ",PUCHAR:" A_PtrSize ",PUHALF_PTR:" A_PtrSize ",PUINT:" A_PtrSize ",PUINT_PTR:" A_PtrSize "
     ,PUINT32:" A_PtrSize ",PUINT64:" A_PtrSize ",PULONG:" A_PtrSize ",PULONGLONG:" A_PtrSize ",PULONG_PTR:" A_PtrSize ",PULONG32:" A_PtrSize "
     ,PULONG64:" A_PtrSize ",PUSHORT:" A_PtrSize ",PVOID:" A_PtrSize ",PWCHAR:" A_PtrSize ",PWORD:" A_PtrSize ",PWSTR:" A_PtrSize ",SC_HANDLE:" A_PtrSize "
     ,SC_LOCK:" A_PtrSize ",SERVICE_STATUS_HANDLE:" A_PtrSize ",SIZE_T:" A_PtrSize ",UINT_PTR:" A_PtrSize ",ULONG_PTR:" A_PtrSize ",VOID:" A_PtrSize "
)"
local _,_ArrName_:="",_ArrType_,_ArrSize_,_defobj_,_idx_,_LF_,_LF_BKP_,_match_,_offset_,_padding_,_struct_
,_total_union_size_,_uix_,_union_,_union_size_,_in_struct_,_mod_,_max_size_,_struct_align_
_offset_:=parent_offset
If IsObject(_TYPE_){
return _TYPE_["`a`a"]
}
If RegExMatch(_TYPE_,"^[\w\d\._]+$"){
If InStr(_types_,"," _TYPE_ ":")
Return SubStr(_types_,InStr(_types_,"," _TYPE_ ":") + 2 + StrLen(_TYPE_),1)
else If InStr(_TYPE_,"."){
Loop,Parse,_TYPE_,.
If A_Index=1
_defobj_:=%A_LoopField%
else _defobj_:=_defobj_[A_LoopField]
Return sizeof(_defobj_,parent_offset)
} else Return sizeof(%_TYPE_%,parent_offset)
} else _defobj_:=""
If InStr(_TYPE_,"`n") {
_offset_:=""
,_struct_:=[]
,_union_:=0
Loop,Parse,_TYPE_,`n,`r`t%A_Space%%A_Tab%
{
_LF_:=""
Loop,Parse,A_LoopField,`,`;,`t%A_Space%%A_Tab%
{
If RegExMatch(A_LoopField,"^\s*//")
break
If (A_LoopField){
If (!_LF_ && _ArrType_:=RegExMatch(A_LoopField,"[\w\d_#@]\s+[\w\d_#@]"))
_LF_:=RegExReplace(A_LoopField,"[\w\d_#@]\K\s+.*$")
If Instr(A_LoopField,"{"){
_union_++,_struct_.Insert(_union_,RegExMatch(A_LoopField,"i)^\s*struct\s*\{"))
} else If InStr(A_LoopField,"}")
_offset_.="}"
else {
If _union_
Loop % _union_
_ArrName_.=(_struct_[A_Index]?"struct":"") "{"
_offset_.=(_offset_ ? "," : "") _ArrName_ ((_ArrType_ && A_Index!=1)?(_LF_ " "):"") RegExReplace(A_LoopField,"\s+"," ")
,_ArrName_:="",_union_:=0
}
}
}
}
_TYPE_:=_offset_
,_offset_:=parent_offset
}
_union_:=[]
,_struct_:=[]
,_union_size_:=[]
,_struct_align_:=[]
,_total_union_size_:=0
,_in_struct_:=1
Loop,Parse,_TYPE_,`,`;
{
_in_struct_+=StrLen(A_LoopField)+1
If ("" = _LF_ := trim(A_LoopField,A_Space A_Tab "`n`r"))
continue
_LF_BKP_:=_LF_
While (_match_:=RegExMatch(_LF_,"i)^(struct|union)?\s*\{\K"))
_max_size_:=sizeof_maxsize(SubStr(_TYPE_,_in_struct_-StrLen(A_LoopField)-1+(StrLen(_LF_BKP_)-StrLen(_LF_))))
,_union_.Insert(_offset_+=(_mod_:=Mod(_offset_,_max_size_))?Mod(_max_size_-_mod_,_max_size_):0)
,_union_size_.Insert(0)
,_struct_align_.Insert(_align_total_>_max_size_?_align_total_:_max_size_)
,_struct_.Insert(RegExMatch(_LF_,"i)^struct\s*\{")?(1,_align_total_:=0):0)
,_LF_:=SubStr(_LF_,_match_)
StringReplace,_LF_,_LF_,},,A
If InStr(_LF_,"*"){
_offset_ += (_mod_:=Mod(_offset_ + A_PtrSize,A_PtrSize)?A_PtrSize-_mod_:0) + A_PtrSize
,_align_total_:=_align_total_<A_PtrSize?A_PtrSize:_align_total_
} else {
RegExMatch(_LF_,"^(?<ArrType_>[\w\d\._#@]+)?\s*(?<ArrName_>[\w\d\._#@]+)?\s*\[?(?<ArrSize_>\d+)?\]?\s*$",_)
If (!_ArrName_ && !_ArrSize_ && !InStr( _types_  ,"," _ArrType_ ":"))
_ArrName_:=_ArrType_,_ArrType_:="UInt"
If InStr(_ArrType_,"."){
Loop,Parse,_ArrType_,.
If A_Index=1
_defobj_:=%A_LoopField%
else _defobj_:=_defobj_[A_LoopField]
}
If (_idx_:=InStr( _types_  ,"," _ArrType_ ":"))
_padding_:=SubStr( _types_  , _idx_+StrLen(_ArrType_)+2 , 1 ),_align_total_:=_align_total_<_padding_?_padding_:_align_total_
else _padding_:= sizeof(_defobj_?_defobj_:%_ArrType_%,0,_align_total_),_max_size_:=sizeof_maxsize(_defobj_?_defobj_:%_ArrType_%)
if (_max_size_){
if (_mod_:=Mod(_offset_,_max_size_))
_offset_ += Mod(_max_size_-_mod_,_max_size_)
} else if _mod_:=Mod(_offset_,_padding_)
_offset_ += Mod(_padding_-_mod_,_padding_)
_offset_ += (_padding_ * (_ArrSize_?_ArrSize_:1))
_max_size_:=0
}
If (_uix_:=_union_.MaxIndex()) && (_max_size_:=_offset_ - _union_[_uix_])>_union_size_[_uix_]
_union_size_[_uix_]:=_max_size_
_max_size_:=0
If (_uix_ && !_struct_[_uix_])
_offset_:=_union_[_uix_]
While (SubStr(_LF_BKP_,0)="}"){
If !(_uix_:=_union_.MaxIndex()){
MsgBox,0, Incorrect structure, missing opening braket {`nProgram will exit now `n%_TYPE_%
ExitApp
}
if (_uix_>1 && _struct_[_uix_-1]){
If (_mod_:=Mod(_offset_,_struct_align_[_uix_]))
_offset_+=Mod(_struct_align_[_uix_]-_mod_,_struct_align_[_uix_])
} else _offset_:=_union_[_uix_]
if (_struct_[_uix_] &&_struct_align_[_uix_]>_align_total_)
_align_total_ := _struct_align_[_uix_]
_total_union_size_ := _union_size_[_uix_]>_total_union_size_?_union_size_[_uix_]:_total_union_size_
,_union_.Remove() ,_struct_.Remove() ,_union_size_.Remove(),_struct_align_.Remove()
,_LF_BKP_:=SubStr(_LF_BKP_,1,StrLen(_LF_BKP_)-1)
If (_uix_=1){
if (_mod_:=Mod(_total_union_size_,_align_total_))
_total_union_size_ += Mod(_align_total_-_mod_,_align_total_)
_offset_+=_total_union_size_,_total_union_size_:=0
}
}
}
_offset_+= Mod(_align_total_ - Mod(_offset_,_align_total_),_align_total_)
Return _offset_
}
sizeof_maxsize(s){
static _types__:="
  (LTrim Join
    ,ATOM:2,LANGID:2,WCHAR:2,WORD:2,PTR:" A_PtrSize ",UPTR:" A_PtrSize ",SHORT:2,USHORT:2,INT:4,UINT:4,INT64:8,UINT64:8,DOUBLE:8,FLOAT:4,CHAR:1,UCHAR:1,__int64:8
    ,TBYTE:" (A_IsUnicode?2:1) ",TCHAR:" (A_IsUnicode?2:1) ",HALF_PTR:" (A_PtrSize=8?4:2) ",UHALF_PTR:" (A_PtrSize=8?4:2) ",INT32:4,LONG:4,LONG32:4,LONGLONG:8
    ,LONG64:8,USN:8,HFILE:4,HRESULT:4,INT_PTR:" A_PtrSize ",LONG_PTR:" A_PtrSize ",POINTER_64:" A_PtrSize ",POINTER_SIGNED:" A_PtrSize "
    ,BOOL:4,SSIZE_T:" A_PtrSize ",WPARAM:" A_PtrSize ",BOOLEAN:1,BYTE:1,COLORREF:4,DWORD:4,DWORD32:4,LCID:4,LCTYPE:4,LGRPID:4,LRESULT:4,PBOOL:" A_PtrSize "
    ,PBOOLEAN:" A_PtrSize ",PBYTE:" A_PtrSize ",PCHAR:" A_PtrSize ",PCSTR:" A_PtrSize ",PCTSTR:" A_PtrSize ",PCWSTR:" A_PtrSize ",PDWORD:" A_PtrSize "
    ,PDWORDLONG:" A_PtrSize ",PDWORD_PTR:" A_PtrSize ",PDWORD32:" A_PtrSize ",PDWORD64:" A_PtrSize ",PFLOAT:" A_PtrSize ",PHALF_PTR:" A_PtrSize "
    ,UINT32:4,ULONG:4,ULONG32:4,DWORDLONG:8,DWORD64:8,ULONGLONG:8,ULONG64:8,DWORD_PTR:" A_PtrSize ",HACCEL:" A_PtrSize ",HANDLE:" A_PtrSize "
     ,HBITMAP:" A_PtrSize ",HBRUSH:" A_PtrSize ",HCOLORSPACE:" A_PtrSize ",HCONV:" A_PtrSize ",HCONVLIST:" A_PtrSize ",HCURSOR:" A_PtrSize ",HDC:" A_PtrSize "
     ,HDDEDATA:" A_PtrSize ",HDESK:" A_PtrSize ",HDROP:" A_PtrSize ",HDWP:" A_PtrSize ",HENHMETAFILE:" A_PtrSize ",HFONT:" A_PtrSize ",USAGE:" 2 "
)"
static _types_:=_types__ "
  (LTrim Join
     ,HGDIOBJ:" A_PtrSize ",HGLOBAL:" A_PtrSize ",HHOOK:" A_PtrSize ",HICON:" A_PtrSize ",HINSTANCE:" A_PtrSize ",HKEY:" A_PtrSize ",HKL:" A_PtrSize "
     ,HLOCAL:" A_PtrSize ",HMENU:" A_PtrSize ",HMETAFILE:" A_PtrSize ",HMODULE:" A_PtrSize ",HMONITOR:" A_PtrSize ",HPALETTE:" A_PtrSize ",HPEN:" A_PtrSize "
     ,HRGN:" A_PtrSize ",HRSRC:" A_PtrSize ",HSZ:" A_PtrSize ",HWINSTA:" A_PtrSize ",HWND:" A_PtrSize ",LPARAM:" A_PtrSize ",LPBOOL:" A_PtrSize ",LPBYTE:" A_PtrSize "
     ,LPCOLORREF:" A_PtrSize ",LPCSTR:" A_PtrSize ",LPCTSTR:" A_PtrSize ",LPCVOID:" A_PtrSize ",LPCWSTR:" A_PtrSize ",LPDWORD:" A_PtrSize ",LPHANDLE:" A_PtrSize "
     ,LPINT:" A_PtrSize ",LPLONG:" A_PtrSize ",LPSTR:" A_PtrSize ",LPTSTR:" A_PtrSize ",LPVOID:" A_PtrSize ",LPWORD:" A_PtrSize ",LPWSTR:" A_PtrSize "
     ,PHANDLE:" A_PtrSize ",PHKEY:" A_PtrSize ",PINT:" A_PtrSize ",PINT_PTR:" A_PtrSize ",PINT32:" A_PtrSize ",PINT64:" A_PtrSize ",PLCID:" A_PtrSize "
     ,PLONG:" A_PtrSize ",PLONGLONG:" A_PtrSize ",PLONG_PTR:" A_PtrSize ",PLONG32:" A_PtrSize ",PLONG64:" A_PtrSize ",POINTER_32:" A_PtrSize "
     ,POINTER_UNSIGNED:" A_PtrSize ",PSHORT:" A_PtrSize ",PSIZE_T:" A_PtrSize ",PSSIZE_T:" A_PtrSize ",PSTR:" A_PtrSize ",PTBYTE:" A_PtrSize "
     ,PTCHAR:" A_PtrSize ",PTSTR:" A_PtrSize ",PUCHAR:" A_PtrSize ",PUHALF_PTR:" A_PtrSize ",PUINT:" A_PtrSize ",PUINT_PTR:" A_PtrSize "
     ,PUINT32:" A_PtrSize ",PUINT64:" A_PtrSize ",PULONG:" A_PtrSize ",PULONGLONG:" A_PtrSize ",PULONG_PTR:" A_PtrSize ",PULONG32:" A_PtrSize "
     ,PULONG64:" A_PtrSize ",PUSHORT:" A_PtrSize ",PVOID:" A_PtrSize ",PWCHAR:" A_PtrSize ",PWORD:" A_PtrSize ",PWSTR:" A_PtrSize ",SC_HANDLE:" A_PtrSize "
     ,SC_LOCK:" A_PtrSize ",SERVICE_STATUS_HANDLE:" A_PtrSize ",SIZE_T:" A_PtrSize ",UINT_PTR:" A_PtrSize ",ULONG_PTR:" A_PtrSize ",VOID:" A_PtrSize "
)"
max:=0,i:=0
s:=trim(s,"`n`r`t ")
If InStr(s,"}"){
Loop,Parse,s
if (A_LoopField="{")
i++
else if (A_LoopField="}"){
if --i<1{
end:=A_Index
break
}
}
if end
s:=SubStr(s,1,end)
}
Loop,Parse,s,`n,`r
{
_struct_:=(i:=InStr(A_LoopField," //"))?SubStr(A_LoopField,1,i):A_LoopField
Loop,Parse,_struct_,`;`,{},%A_Space%%A_Tab%
if A_LoopField&&!InStr(".union.struct.","." A_LoopField ".")
if (!InStr(A_LoopField,A_Tab)&&!InStr(A_LoopField," "))
max:=max<4?4:max
else if (sizeof(A_LoopField,0,size:=0) && max<size)
max:=size
}
return max
}
Class _Struct {
static PTR:=A_PtrSize,UPTR:=A_PtrSize,SHORT:=2,USHORT:=2,INT:=4,UINT:=4,__int64:=8,INT64:=8,UINT64:=8,DOUBLE:=8,FLOAT:=4,CHAR:=1,UCHAR:=1,VOID:=A_PtrSize
,TBYTE:=A_IsUnicode?2:1,TCHAR:=A_IsUnicode?2:1,HALF_PTR:=A_PtrSize=8?4:2,UHALF_PTR:=A_PtrSize=8?4:2,INT32:=4,LONG:=4,LONG32:=4,LONGLONG:=8
,LONG64:=8,USN:=8,HFILE:=4,HRESULT:=4,INT_PTR:=A_PtrSize,LONG_PTR:=A_PtrSize,POINTER_64:=A_PtrSize,POINTER_SIGNED:=A_PtrSize
,BOOL:=4,SSIZE_T:=A_PtrSize,WPARAM:=A_PtrSize,BOOLEAN:=1,BYTE:=1,COLORREF:=4,DWORD:=4,DWORD32:=4,LCID:=4,LCTYPE:=4,LGRPID:=4,LRESULT:=4,PBOOL:=4
,PBOOLEAN:=A_PtrSize,PBYTE:=A_PtrSize,PCHAR:=A_PtrSize,PCSTR:=A_PtrSize,PCTSTR:=A_PtrSize,PCWSTR:=A_PtrSize,PDWORD:=A_PtrSize,PDWORDLONG:=A_PtrSize
,PDWORD_PTR:=A_PtrSize,PDWORD32:=A_PtrSize,PDWORD64:=A_PtrSize,PFLOAT:=A_PtrSize,PHALF_PTR:=A_PtrSize
,UINT32:=4,ULONG:=4,ULONG32:=4,DWORDLONG:=8,DWORD64:=8,ULONGLONG:=8,ULONG64:=8,DWORD_PTR:=A_PtrSize,HACCEL:=A_PtrSize,HANDLE:=A_PtrSize
,HBITMAP:=A_PtrSize,HBRUSH:=A_PtrSize,HCOLORSPACE:=A_PtrSize,HCONV:=A_PtrSize,HCONVLIST:=A_PtrSize,HCURSOR:=A_PtrSize,HDC:=A_PtrSize
,HDDEDATA:=A_PtrSize,HDESK:=A_PtrSize,HDROP:=A_PtrSize,HDWP:=A_PtrSize,HENHMETAFILE:=A_PtrSize,HFONT:=A_PtrSize
static HGDIOBJ:=A_PtrSize,HGLOBAL:=A_PtrSize,HHOOK:=A_PtrSize,HICON:=A_PtrSize,HINSTANCE:=A_PtrSize,HKEY:=A_PtrSize,HKL:=A_PtrSize
,HLOCAL:=A_PtrSize,HMENU:=A_PtrSize,HMETAFILE:=A_PtrSize,HMODULE:=A_PtrSize,HMONITOR:=A_PtrSize,HPALETTE:=A_PtrSize,HPEN:=A_PtrSize
,HRGN:=A_PtrSize,HRSRC:=A_PtrSize,HSZ:=A_PtrSize,HWINSTA:=A_PtrSize,HWND:=A_PtrSize,LPARAM:=A_PtrSize,LPBOOL:=A_PtrSize,LPBYTE:=A_PtrSize
,LPCOLORREF:=A_PtrSize,LPCSTR:=A_PtrSize,LPCTSTR:=A_PtrSize,LPCVOID:=A_PtrSize,LPCWSTR:=A_PtrSize,LPDWORD:=A_PtrSize,LPHANDLE:=A_PtrSize
,LPINT:=A_PtrSize,LPLONG:=A_PtrSize,LPSTR:=A_PtrSize,LPTSTR:=A_PtrSize,LPVOID:=A_PtrSize,LPWORD:=A_PtrSize,LPWSTR:=A_PtrSize,PHANDLE:=A_PtrSize
,PHKEY:=A_PtrSize,PINT:=A_PtrSize,PINT_PTR:=A_PtrSize,PINT32:=A_PtrSize,PINT64:=A_PtrSize,PLCID:=A_PtrSize,PLONG:=A_PtrSize,PLONGLONG:=A_PtrSize
,PLONG_PTR:=A_PtrSize,PLONG32:=A_PtrSize,PLONG64:=A_PtrSize,POINTER_32:=A_PtrSize,POINTER_UNSIGNED:=A_PtrSize,PSHORT:=A_PtrSize,PSIZE_T:=A_PtrSize
,PSSIZE_T:=A_PtrSize,PSTR:=A_PtrSize,PTBYTE:=A_PtrSize,PTCHAR:=A_PtrSize,PTSTR:=A_PtrSize,PUCHAR:=A_PtrSize,PUHALF_PTR:=A_PtrSize,PUINT:=A_PtrSize
,PUINT_PTR:=A_PtrSize,PUINT32:=A_PtrSize,PUINT64:=A_PtrSize,PULONG:=A_PtrSize,PULONGLONG:=A_PtrSize,PULONG_PTR:=A_PtrSize,PULONG32:=A_PtrSize
,PULONG64:=A_PtrSize,PUSHORT:=A_PtrSize,PVOID:=A_PtrSize,PWCHAR:=A_PtrSize,PWORD:=A_PtrSize,PWSTR:=A_PtrSize,SC_HANDLE:=A_PtrSize
,SC_LOCK:=A_PtrSize,SERVICE_STATUS_HANDLE:=A_PtrSize,SIZE_T:=A_PtrSize,UINT_PTR:=A_PtrSize,ULONG_PTR:=A_PtrSize,ATOM:=2,LANGID:=2,WCHAR:=2,WORD:=2,USAGE:=2
static _PTR:="PTR",_UPTR:="UPTR",_SHORT:="Short",_USHORT:="UShort",_INT:="Int",_UINT:="UInt"
,_INT64:="Int64",_UINT64:="UInt64",_DOUBLE:="Double",_FLOAT:="Float",_CHAR:="Char",_UCHAR:="UChar"
,_VOID:="PTR",_TBYTE:=A_IsUnicode?"USHORT":"UCHAR",_TCHAR:=A_IsUnicode?"USHORT":"UCHAR",_HALF_PTR:=A_PtrSize=8?"INT":"SHORT"
,_UHALF_PTR:=A_PtrSize=8?"UINT":"USHORT",_BOOL:="Int",_INT32:="Int",_LONG:="Int",_LONG32:="Int",_LONGLONG:="Int64",_LONG64:="Int64"
,_USN:="Int64",_HFILE:="UInt",_HRESULT:="UInt",_INT_PTR:="PTR",_LONG_PTR:="PTR",_POINTER_64:="PTR",_POINTER_SIGNED:="PTR",_SSIZE_T:="PTR"
,_WPARAM:="PTR",_BOOLEAN:="UCHAR",_BYTE:="UCHAR",_COLORREF:="UInt",_DWORD:="UInt",_DWORD32:="UInt",_LCID:="UInt",_LCTYPE:="UInt"
,_LGRPID:="UInt",_LRESULT:="UInt",_PBOOL:="UPTR",_PBOOLEAN:="UPTR",_PBYTE:="UPTR",_PCHAR:="UPTR",_PCSTR:="UPTR",_PCTSTR:="UPTR"
,_PCWSTR:="UPTR",_PDWORD:="UPTR",_PDWORDLONG:="UPTR",_PDWORD_PTR:="UPTR",_PDWORD32:="UPTR",_PDWORD64:="UPTR",_PFLOAT:="UPTR",___int64:="Int64"
,_PHALF_PTR:="UPTR",_UINT32:="UInt",_ULONG:="UInt",_ULONG32:="UInt",_DWORDLONG:="UInt64",_DWORD64:="UInt64",_ULONGLONG:="UInt64"
,_ULONG64:="UInt64",_DWORD_PTR:="UPTR",_HACCEL:="UPTR",_HANDLE:="UPTR",_HBITMAP:="UPTR",_HBRUSH:="UPTR",_HCOLORSPACE:="UPTR"
,_HCONV:="UPTR",_HCONVLIST:="UPTR",_HCURSOR:="UPTR",_HDC:="UPTR",_HDDEDATA:="UPTR",_HDESK:="UPTR",_HDROP:="UPTR",_HDWP:="UPTR"
static _HENHMETAFILE:="UPTR",_HFONT:="UPTR",_HGDIOBJ:="UPTR",_HGLOBAL:="UPTR",_HHOOK:="UPTR",_HICON:="UPTR",_HINSTANCE:="UPTR",_HKEY:="UPTR"
,_HKL:="UPTR",_HLOCAL:="UPTR",_HMENU:="UPTR",_HMETAFILE:="UPTR",_HMODULE:="UPTR",_HMONITOR:="UPTR",_HPALETTE:="UPTR",_HPEN:="UPTR"
,_HRGN:="UPTR",_HRSRC:="UPTR",_HSZ:="UPTR",_HWINSTA:="UPTR",_HWND:="UPTR",_LPARAM:="UPTR",_LPBOOL:="UPTR",_LPBYTE:="UPTR",_LPCOLORREF:="UPTR"
,_LPCSTR:="UPTR",_LPCTSTR:="UPTR",_LPCVOID:="UPTR",_LPCWSTR:="UPTR",_LPDWORD:="UPTR",_LPHANDLE:="UPTR",_LPINT:="UPTR",_LPLONG:="UPTR"
,_LPSTR:="UPTR",_LPTSTR:="UPTR",_LPVOID:="UPTR",_LPWORD:="UPTR",_LPWSTR:="UPTR",_PHANDLE:="UPTR",_PHKEY:="UPTR",_PINT:="UPTR"
,_PINT_PTR:="UPTR",_PINT32:="UPTR",_PINT64:="UPTR",_PLCID:="UPTR",_PLONG:="UPTR",_PLONGLONG:="UPTR",_PLONG_PTR:="UPTR",_PLONG32:="UPTR"
,_PLONG64:="UPTR",_POINTER_32:="UPTR",_POINTER_UNSIGNED:="UPTR",_PSHORT:="UPTR",_PSIZE_T:="UPTR",_PSSIZE_T:="UPTR",_PSTR:="UPTR"
,_PTBYTE:="UPTR",_PTCHAR:="UPTR",_PTSTR:="UPTR",_PUCHAR:="UPTR",_PUHALF_PTR:="UPTR",_PUINT:="UPTR",_PUINT_PTR:="UPTR",_PUINT32:="UPTR"
,_PUINT64:="UPTR",_PULONG:="UPTR",_PULONGLONG:="UPTR",_PULONG_PTR:="UPTR",_PULONG32:="UPTR",_PULONG64:="UPTR",_PUSHORT:="UPTR"
,_PVOID:="UPTR",_PWCHAR:="UPTR",_PWORD:="UPTR",_PWSTR:="UPTR",_SC_HANDLE:="UPTR",_SC_LOCK:="UPTR",_SERVICE_STATUS_HANDLE:="UPTR"
static _SIZE_T:="UPTR",_UINT_PTR:="UPTR",_ULONG_PTR:="UPTR",_ATOM:="Ushort",_LANGID:="Ushort",_WCHAR:="Ushort",_WORD:="UShort",_USAGE:="UShort"
___InitField(_this,N,offset=" ",encoding=0,AHKType=0,isptr=" ",type=0,arrsize=0,memory=0){
static _prefixes_:={offset:"`b",isptr:"`r",AHKType:"`n",type:"`t",encoding:"`f",memory:"`v",arrsize:" "}
,_testtype_:={offset:"integer",isptr:"integer",AHKType:"string",type:"string",encoding:"string",arrsize:"integer"}
,_default_:={offset:0,isptr:0,AHKType:"UInt",type:"UINT",encoding:"CP0",memory:"",arrsize:1}
for _key_,_value_ in _prefixes_
{
_typevalid_:=0
If (_testtype_[_key_]="Integer"){
If %_key_% is integer
useDefault:=1,_typevalid_:=1
else if !_this.HasKey(_value_ N)
useDefault:=1
} else {
If %_key_% is not integer
useDefault:=1,_typevalid_:=1
else if !_this.HasKey(_value_ N)
useDefault:=1
}
If (useDefault)
If (_key_="encoding")
_this[_value_ N]:=_typevalid_?(InStr(",LPTSTR,LPCTSTR,TCHAR,","," %_key_% ",")?(A_IsUnicode?"UTF-16":"CP0")
:InStr(",LPWSTR,LPCWSTR,WCHAR,","," %_key_% ",")?"UTF-16":"CP0")
:_default_[_key_]
else {
_this[_value_ N]:=_typevalid_?%_key_%:_default_[_key_]
}
}
}
__NEW(_TYPE_,_pointer_=0,_init_=0){
static _base_:={__GET:_Struct.___GET,__SET:_Struct.___SET,__SETPTR:_Struct.___SETPTR,__Clone:_Struct.___Clone,__NEW:_Struct.___NEW
,IsPointer:_Struct.IsPointer,Offset:_Struct.Offset,Type:_Struct.Type,AHKType:_Struct.AHKType,Encoding:_Struct.Encoding
,Capacity:_Struct.Capacity,Alloc:_Struct.Alloc,Size:_Struct.Size,SizeT:_Struct.SizeT,Print:_Struct.Print,ToObj:_Struct.ToObj}
local _,_ArrType_,_ArrName_:="",_ArrSize_,_align_total_,_defobj_,_IsPtr_,_key_,_LF_,_LF_BKP_,_match_,_offset_:=""
,_struct_,_StructSize_,_total_union_size_,_union_,_union_size_,_value_,_mod_,_max_size_,_in_struct_,_struct_align_
If (RegExMatch(_TYPE_,"^[\w\d\._]+$") && !_Struct.HasKey(_TYPE_)){
If InStr(_TYPE_,"."){
Loop,Parse,_TYPE_,.
If A_Index=1
_defobj_:=%A_LoopField%
else _defobj_:=_defobj_[A_LoopField]
_TYPE_:=_defobj_
} else _TYPE_:=%_TYPE_%,_defobj_:=""
} else _defobj_:=""
If (_pointer_ && !IsObject(_pointer_))
this[""] := _pointer_,this["`a"]:=0,this["`a`a"]:=sizeof(_TYPE_)
else
this._SetCapacity("`a",_StructSize_:=sizeof(_TYPE_))
,this[""]:=this._GetAddress("`a")
,DllCall("RtlZeroMemory","UPTR",this[""],"UInt",this["`a`a"]:=_StructSize_)
If InStr(_TYPE_,"`n") {
_struct_:=[]
_union_:=0
Loop,Parse,_TYPE_,`n,`r`t%A_Space%%A_Tab%
{
_LF_:=""
Loop,Parse,A_LoopField,`,`;,`t%A_Space%%A_Tab%
{
If RegExMatch(A_LoopField,"^\s*//")
break
If (A_LoopField){
If (!_LF_ && _ArrType_:=RegExMatch(A_LoopField,"[\w\d_#@]\s+[\w\d_#@]"))
_LF_:=RegExReplace(A_LoopField,"[\w\d_#@]\K\s+.*$")
If Instr(A_LoopField,"{"){
_union_++,_struct_.Insert(_union_,RegExMatch(A_LoopField,"i)^\s*struct\s*\{"))
} else If InStr(A_LoopField,"}")
_offset_.="}"
else {
If _union_
Loop % _union_
_ArrName_.=(_struct_[A_Index]?"struct":"") "{"
_offset_.=(_offset_ ? "," : "") _ArrName_ ((_ArrType_ && A_Index!=1)?(_LF_ " "):"") RegExReplace(A_LoopField,"\s+"," ")
,_ArrName_:="",_union_:=0
}
}
}
}
_TYPE_:=_offset_
}
_offset_:=0
,_union_:=[]
,_struct_:=[]
,_union_size_:=[]
,_struct_align_:=[]
,_total_union_size_:=0
,_align_total_:=0
,_in_struct_:=1
,this["`t"]:=0,this["`r"]:=0
Loop,Parse,_TYPE_,`,`;
{
_in_struct_+=StrLen(A_LoopField)+1
If ("" = _LF_ := trim(A_LoopField,A_Space A_Tab "`n`r"))
continue
_LF_BKP_:=_LF_
_IsPtr_:=0
While (_match_:=RegExMatch(_LF_,"i)^(struct|union)?\s*\{\K"))
_max_size_:=sizeof_maxsize(SubStr(_TYPE_,_in_struct_-StrLen(A_LoopField)-1+(StrLen(_LF_BKP_)-StrLen(_LF_))))
,_union_.Insert(_offset_+=(_mod_:=Mod(_offset_,_max_size_))?Mod(_max_size_-_mod_,_max_size_):0)
,_union_size_.Insert(0)
,_struct_align_.Insert(_align_total_>_max_size_?_align_total_:_max_size_)
,_struct_.Insert(RegExMatch(_LF_,"i)^struct\s*\{")?(1,_align_total_:=0):0)
,_LF_:=SubStr(_LF_,_match_)
StringReplace,_LF_,_LF_,},,A
While % (InStr(_LF_,"*")){
StringReplace,_LF_,_LF_,*
_IsPtr_:=A_Index
}
RegExMatch(_LF_,"^(?<ArrType_>[\w\d\._]+)?\s*(?<ArrName_>[\w\d_]+)?\s*\[?(?<ArrSize_>\d+)?\]?\s*\}*\s*$",_)
If (!_ArrName_ && !_ArrSize_){
If RegExMatch(_TYPE_,"^\**" _ArrType_ "\**$"){
_Struct.___InitField(this,"",0,_ArrType_,_IsPtr_?"PTR":_Struct.HasKey("_" _ArrType_)?_Struct["_" _ArrType_]:"PTR",_IsPtr_,_ArrType_)
this.base:=_base_
If (IsObject(_init_)||IsObject(_pointer_)){
for _key_,_value_ in IsObject(_init_)?_init_:_pointer_
{
If !this["`r"]{
If InStr(",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR,","," this["`t" _key_] ",")
this.Alloc(_key_,StrLen(_value_)*(InStr(".LPWSTR,LPCWSTR,","," this["`t"] ",")||(InStr(",LPTSTR,LPCTSTR,","," this["`t" _key_] ",")&&A_IsUnicode)?2:1))
if InStr(",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR,CHAR,TCHAR,WCHAR,","," this["`t" _key_] ",")
this[_key_]:=_value_
else
this[_key_] := _value_
}else if (_value_<>"")
If _value_ is integer
this[_key_][""]:=_value_
}
}
Return this
} else
_ArrName_:=_ArrType_,_ArrType_:="UInt"
}
If InStr(_ArrType_,"."){
Loop,Parse,_ArrType_,.
If A_Index=1
_defobj_:=%A_LoopField%
else _defobj_:=_defobj_[A_LoopField]
}
if (!_IsPtr_ && !_Struct.HasKey(_ArrType_)){
if (sizeof(_defobj_?_defobj_:%_ArrType_%,0,_align_total_) && mod:=Mod(_offset_,_align_total_))
_offset_+=Mod(_align_total_-_mod_,_align_total_)
_Struct.___InitField(this,_ArrName_,_offset_,_ArrType_,0,0,_ArrType_,_ArrSize_)
If (_uix_:=_union_.MaxIndex()) && (_max_size_:=_offset_ + sizeof(_defobj_?_defobj_:%_ArrType_%) - _union_[_uix_])>_union_size_[_uix_]
_union_size_[_uix_]:=_max_size_
_max_size:=0
If (!_uix_||_struct_[_struct_.MaxIndex()])
_offset_+=this[" " _ArrName_]*sizeof(_defobj_?_defobj_:%_ArrType_%)
} else {
If ((_IsPtr_ || _Struct.HasKey(_ArrType_)))
_offset_+=(_mod_:=Mod(_offset_,_max_size_:=_IsPtr_?A_PtrSize:_Struct[_ArrType_]))=0?0:(_IsPtr_?A_PtrSize:_Struct[_ArrType_])-_mod_
,_align_total_:=_max_size_>_align_total_?_max_size_:_align_total_
,_Struct.___InitField(this,_ArrName_,_offset_,_ArrType_,_IsPtr_?"PTR":_Struct.HasKey(_ArrType_)?_Struct["_" _ArrType_]:_ArrType_,_IsPtr_,_ArrType_,_ArrSize_)
If (_uix_:=_union_.MaxIndex()) && (_max_size_:=_offset_ + _Struct[this["`n" _ArrName_]] - _union_[_uix_])>_union_size_[_uix_]
_union_size_[_uix_]:=_max_size_
_max_size_:=0
If (!_uix_||_struct_[_uix_])
_offset_+=_IsPtr_?A_PtrSize:(_Struct.HasKey(_ArrType_)?_Struct[_ArrType_]:%_ArrType_%)*this[" " _ArrName_]
}
While (SubStr(_LF_BKP_,0)="}"){
If (!_uix_:=_union_.MaxIndex()){
MsgBox,0, Incorrect structure, missing opening braket {`nProgram will exit now `n%_TYPE_%
ExitApp
}
if (_uix_>1 && _struct_[_uix_-1]){
if (_mod_:=Mod(_offset_,_struct_align_[_uix_]))
_offset_+=Mod(_struct_align_[_uix_]-_mod_,_struct_align_[_uix_])
} else _offset_:=_union_[_uix_]
if (_struct_[_uix_]&&_struct_align_[_uix_]>_align_total_)
_align_total_ := _struct_align_[_uix_]
_total_union_size_ := _union_size_[_uix_]>_total_union_size_?_union_size_[_uix_]:_total_union_size_
,_union_._Remove(),_struct_._Remove(),_union_size_._Remove(),_struct_align_.Remove(),_LF_BKP_:=SubStr(_LF_BKP_,1,StrLen(_LF_BKP_)-1)
If (_uix_=1){
if (_mod_:=Mod(_total_union_size_,_align_total_))
_total_union_size_ += Mod(_align_total_-_mod_,_align_total_)
_offset_+=_total_union_size_,_total_union_size_:=0
}
}
}
this.base:=_base_
If (IsObject(_init_)||IsObject(_pointer_)){
for _key_,_value_ in IsObject(_init_)?_init_:_pointer_
{
If !this["`r" _key_]{
If InStr(",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR,","," this["`t" _key_] ",")
this.Alloc(_key_,StrLen(_value_)*(InStr(".LPWSTR,LPCWSTR,","," this["`t"] ",")||(InStr(",LPTSTR,LPCTSTR,","," this["`t" _key_] ",")&&A_IsUnicode)?2:1))
if InStr(",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR,CHAR,TCHAR,WCHAR,","," this["`t" _key_] ",")
this[_key_]:=_value_
else
this[_key_] := _value_
}else if (_value_<>"")
if _value_ is integer
this[_key_][""]:=_value_
}
}
Return this
}
ToObj(struct:=""){
obj:=[]
for k,v in struct?struct:struct:=this
if (Asc(k)=10)
If IsObject(_VALUE_:=struct[_TYPE_:=SubStr(k,2)])
obj[_TYPE_]:=this.ToObj(_VALUE_)
else obj[_TYPE_]:=_VALUE_
return obj
}
SizeT(_key_=""){
return sizeof(this["`t" _key_])
}
Size(){
return sizeof(this)
}
IsPointer(_key_=""){
return this["`r" _key_]
}
Type(_key_=""){
return this["`t" _key_]
}
AHKType(_key_=""){
return this["`n" _key_]
}
Offset(_key_=""){
return this["`b" _key_]
}
Encoding(_key_=""){
return this["`b" _key_]
}
Capacity(_key_=""){
return this._GetCapacity("`v" _key_)
}
Alloc(_key_="",size="",ptrsize=0){
If _key_ is integer
ptrsize:=size,size:=_key_,_key_:=""
If size is integer
SizeIsInt:=1
If ptrsize {
If (this._SetCapacity("`v" _key_,!SizeIsInt?A_PtrSize+ptrsize:size + (size//A_PtrSize)*ptrsize)="")
MsgBox % "Memory for pointer ." _key_ ". of size " (SizeIsInt?size:A_PtrSize) " could not be set!"
else {
DllCall("RtlZeroMemory","UPTR",this._GetAddress("`v" _key_),"UInt",this._GetCapacity("`v" _key_))
If (this[" " _key_]>1){
ptr:=this[""] + this["`b" _key_]
If (this["`r" _key_] || InStr(",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR,","," this["`t" _key_] ","))
NumPut(ptrs:=this._GetAddress("`v" _key_),ptr+0,"PTR")
else if _key_
this[_key_,""]:=ptrs:=this._GetAddress("`v" _key_)
else this[""]:=ptr:=this._GetAddress("`v" _key_),ptrs:=this._GetAddress("`v" _key_)+(SizeIsInt?size:A_PtrSize)
} else {
If (this["`r" _key_] || InStr(",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR,","," this["`t" _key_] ","))
NumPut(ptr:=this._GetAddress("`v" _key_),this[""] + this["`b" _key_],"PTR")
else this[""]:=ptr:=this._GetAddress("`v" _key_)
ptrs:=ptr+(size?size:A_PtrSize)
}
Loop % SizeIsInt?(size//A_PtrSize):1
NumPut(ptrs+(A_Index-1)*ptrsize,ptr+(A_Index-1)*A_PtrSize,"PTR")
}
} else {
If (this._SetCapacity("`v" _key_,SizeIsInt?size:A_PtrSize)=""){
MsgBox % "Memory for pointer ." _key_ ". of size " (SizeIsInt?size:A_PtrSize) " could not be set!"
} else
NumPut(ptr:=this._GetAddress("`v" _key_),this[""] + this["`b" _key_],"PTR"),DllCall("RtlZeroMemory","UPTR",ptr,"UInt",SizeIsInt?size:A_PtrSize)
}
return ptr
}
___NEW(init*){
this:=this.base
newobj := this.__Clone(1)
If (init.MaxIndex() && !IsObject(init.1))
newobj[""] := init.1
else If (init.MaxIndex()>1 && !IsObject(init.2))
newobj[""] := init.2
else
newobj._SetCapacity("`a",_StructSize_:=sizeof(this))
,newobj[""]:=newobj._GetAddress("`a")
,DllCall("RtlZeroMemory","UPTR",newobj[""],"UInt",_StructSize_)
If (IsObject(init.1)||IsObject(init.2))
for _key_,_value_ in IsObject(init.1)?init.1:init.2
newobj[_key_] := _value_
return newobj
}
___Clone(offset){
static _base_:={__GET:_Struct.___GET,__SET:_Struct.___SET,__SETPTR:_Struct.___SETPTR,__Clone:_Struct.___Clone,__NEW:_Struct.___NEW
,IsPointer:_Struct.IsPointer,Offset:_Struct.Offset,Type:_Struct.Type,AHKType:_Struct.AHKType,Encoding:_Struct.Encoding
,Capacity:_Struct.Capacity,Alloc:_Struct.Alloc,Size:_Struct.Size,SizeT:_Struct.SizeT,Print:_Struct.Print,ToObj:_Struct.ToObj}
If offset=1
return this
newobj:={}
for _key_,_value_ in this
If (_key_!="`a")
newobj[_key_]:=_value_
newobj._SetCapacity("`a",_StructSize_:=sizeof(this))
,newobj[""]:=newobj._GetAddress("`a")
,DllCall("RtlZeroMemory","UPTR",newobj[""],"UInt",_StructSize_)
If this["`r"]{
NumPut(NumGet(this[""],"PTR")+A_PtrSize*(offset-1),newobj[""],"Ptr")
newobj.base:=_base_
} else
newobj.base:=_base_,newobj[]:=this[""]+sizeof(this)*(offset-1)
return newobj
}
___GET(_key_="",p*){
If (_key_="")
Return this[""]
else if !(idx:=p.MaxIndex())
_field_:=_key_,opt:="~"
else {
ObjInsert(p,1,_key_)
opt:=ObjRemove(p),_field_:=_key_:=ObjRemove(p)
for key_,value_ in p
this:=this[value_]
}
If this["`t"]
_key_:=""
If (opt!="~"){
If (opt=""){
If _field_ is integer
return (this["`r"]?NumGet(this[""],"PTR"):this[""])+sizeof(this["`t"])*(_field_-1)
else return this["`r" _key_]?NumGet(this[""]+this["`b" _key_],"PTR"):this[""]+this["`b" _key_]
} else If opt is integer
{
If (_Struct.HasKey("_" this["`t" _key_]) && this[" " _key_]>1) {
If (InStr( ",CHAR,UCHAR,TCHAR,WCHAR," , "," this["`t" _key_] "," )){
Return StrGet(this[""]+this["`b" _key_]+(opt-1)*sizeof(this["`t" _key_]),1,this["`f" _key_])
} else if InStr( ",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR," , "," this["`t" _key_] "," ){
Return StrGet(NumGet(this[""]+this["`b" _key_]+(opt-1)*A_PtrSize,"PTR"),this["`f" _key_])
} else {
Return NumGet(this[""]+this["`b" _key_]+(opt-1)*sizeof(this["`t" _key_]),this["`n" _key_])
}
} else Return new _Struct(this["`t" _key_],this[""]+this["`b" _key_]+(opt-1)*sizeof(this["`t" _key_]))
} else
return this[_key_][opt]
} else If _field_ is integer
{
If (_key_){
return this.__Clone(_field_)
} else if this["`r"] {
Pointer:=""
Loop % (this["`r"]-1)
pointer.="*"
If pointer
Return new _Struct(pointer this["`t"],NumGet(this[""],"PTR")+A_PtrSize*(_field_-1))
else Return new _Struct(pointer this["`t"],NumGet(this[""],"PTR")+sizeof(this["`t"])*(_field_-1)).1
} else if _Struct.HasKey("_" this["`t"]) {
If (InStr( ",CHAR,UCHAR,TCHAR,WCHAR," , "," this["`t"] "," )){
Return StrGet(this[""]+sizeof(this["`t"])*(_field_-1),1,this["`f"])
} else if InStr(",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR," , "," this["`t"] "," ){
Return StrGet(NumGet(this[""]+A_PtrSize*(_field_-1),"PTR"),this["`f"])
} else {
Return NumGet(this[""]+sizeof(this["`t"])*(_field_-1),this["`n"])
}
} else {
Return new _Struct(this["`t"],this[""]+sizeof(this["`t"])*(_field_-1))
}
} else If this["`r" _key_] {
Pointer:=""
Loop % (this["`r" _key_]-1)
pointer.="*"
If (_key_=""){
return this[1][_field_]
} else {
Return new _Struct(pointer this["`t" _key_],NumGet(this[""]+this["`b" _key_],"PTR"))
}
} else if _Struct.HasKey("_" this["`t" _key_]) {
If (this[" " _key_]>1)
Return new _Struct(this["`t" _key_],this[""] + this["`b" _key_])
else If (InStr( ",CHAR,UCHAR,TCHAR,WCHAR," , "," this["`t" _key_] "," )){
Return StrGet(this[""]+this["`b" _key_],1,this["`f" _key_])
} else if InStr( ",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR," , "," this["`t" _key_] "," ){
Return StrGet(NumGet(this[""]+this["`b" _key_],"PTR"),this["`f" _key_])
} else {
Return NumGet(this[""]+this["`b" _key_],this["`n" _key_])
}
} else {
Return new _Struct(this["`t" _key_],this[""]+this["`b" _key_])
}
}
___SET(_key_,p*){
If !(idx:=p.MaxIndex())
return this[""] :=_key_,this._SetCapacity("`a",0)
else if (idx=1)
_value_:=p.1,opt:="~"
else if (idx>1){
ObjInsert(p,1,_key_)
If (p[idx]="")
opt:=ObjRemove(p),_value_:=ObjRemove(p),_key_:=ObjRemove(p)
else _value_:=ObjRemove(p),_key_:=ObjRemove(p),opt:="~"
for key_,value_ in p
this:=this[value_]
}
If this["`t"]
_field_:=_key_,_key_:=""
else _field_:=_key_
If this["`r" _key_] {
If opt is integer
return NumPut(opt,this[""] + this["`b" _key_],"PTR")
else if this.HasKey("`t" _key_) {
Pointer:=""
Loop % (this["`r" _key_]-1)
pointer.="*"
If _key_
Return (new _Struct(pointer this["`t" _key_],NumGet(this[""] + this["`b" _key_],"PTR"))).1:=_value_
else Return (new _Struct(pointer this["`t"],NumGet(this[""],"PTR")))[_field_]:=_value_
} else If _field_ is Integer
if (_key_="")
_this:=this,this:=this.__Clone(_Field_)
If InStr( ",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR," , "," this["`t" _key_] "," )
StrPut(_value_,NumGet(NumGet(this[""]+this["`b" _key_],"PTR"),"PTR"),this["`f" _key_])
else if InStr( ",TCHAR,CHAR,UCHAR,WCHAR," , "," this["`t" _key_] "," ){
StrPut(_value_,NumGet(this[""]+this["`b" _key_],"PTR"),this["`f" _key_])
} else
NumPut(_value_,NumGet(this[""]+this["`b" _key_],"PTR"),this["`n" _key_])
If _field_ is integer
this:=_this
} else if (RegExMatch(_field_,"^\d+$") && _key_="") {
if InStr( ",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR," , "," this["`t"] "," ){
StrPut(_value_,NumGet(this[""]+A_PtrSize*(_field_-1),"PTR"),this["`f"])
} else if InStr( ",TCHAR,CHAR,UCHAR,WCHAR," , "," this["`t" _key_] "," ){
StrPut(_value_,this[""] + sizeof(this["`t"])*(_field_-1),this["`f"])
} else
NumPut(_value_,this[""] + sizeof(this["`t"])*(_field_-1),this["`n"])
} else if opt is integer
{
return NumPut(opt,this[""] + this["`b" _key_],"PTR")
} else if InStr( ",LPSTR,LPCSTR,LPTSTR,LPCTSTR,LPWSTR,LPCWSTR," , "," this["`t" _key_] "," ){
StrPut(_value_,NumGet(this[""] + this["`b" _key_],"PTR"),this["`f" _key_])
} else if InStr( ",TCHAR,CHAR,UCHAR,WCHAR," , "," this["`t" _key_] "," ){
StrPut(_value_,this[""] + this["`b" _key_],this["`f" _key_])
} else
NumPut(_value_,this[""]+this["`b" _key_],this["`n" _key_])
Return _value_
}
}
Class IniFast
{
__New(file, chars = "`r`n", orfans = "<<<orfans>>>", _join=".")
{
if ! fileexist(file)
return
this.orfans := orfans
this.file := file
FileRead, filecontents, %file%
this.contents := filecontents
this.sections := []
current_section := 0
current_section_name := ""
loop, parse, filecontents, % chars
{
if this.isSectionName(A_loopfield)
{
this.sections.insert({})
current_section += 1
current_section_name := A_loopfield
this.sections[current_section][current_section_name] := []
continue
}
if A_loopfield
{
if (current_section_name = "")
{
this.sections.insert({})
current_section += 1
current_section_name := "[" orfans "]"
this.sections[current_section][current_section_name] := []
}
this.sections[current_section][current_section_name].insert(A_loopfield)
}
}
for k, v in this.sections
{
for key, value in v
{
if value[value.maxindex()] != " "
value.insert(" ")
}
}
}
isKey(search_key, sections = "", comment_chars = "", orfans = False)
{
if not comment_chars
comment_chars := ["#"]
if not sections
sections := this.listSections(orfans)
for idx, section in sections
for i, key in this.listKeys(section, comment_chars)
if (key = search_key)
return True
return False
}
listSections(orfans = False)
{
allsecs := []
for k, v in this.sections
{
for key, value in v
{
if not ( (key = "[" this.orfans "]") and (orfans = false) )
{
stringreplace, key, key, ], , 1
stringreplace, key, key, [, , 0
allsecs.insert(key)
}
}
}
return allsecs
}
listKeys(target_section="", comment_chars="#")
{
if ! target_section
target_section := this.orfans
keys := []
comments := ""
in_sec := False
for index, section_name in this.sections
{
for section_, key_value_pars in section_name
{
if not section_ = "[" target_section "]"
continue
else in_sec := True
for index_, value_ in key_value_pars
{
if not instr(value_, "=")
continue
for kk, vv in comment_chars
{
if this.stringStartsWith(value_, vv)
continue 2
}
stringsplit, par, value_, =
keys.insert(par1)
}
if in_sec
break
}
}
return keys
}
show_()
{
for k, v in this.sections
{
for key, value in v
{
fileappend, % key "`n", *
for key_, value_ in value
fileappend, % "-" value_ "`n", *
}
}
}
read(key, target_section = "")
{
if ! target_section
target_section := this.orfans
for index, section_name in this.sections
{
for section_, key_value_pars in section_name
{
if not section_ = "[" target_section "]"
continue
for index_, value_ in key_value_pars
{
par1 := strsplit(value_, "=")[1]
stringreplace, par2, value_, %par1%=
if (par1 = key)
return trim(par2)
}
}
}
return
}
isTrue(key, target_section = "", default_ = False)
{
if (this.read(key, target_section) = "True")
return True
return default_
}
newSection(key, value, target_section)
{
this.sections.insert({})
this.sections[this.sections.MaxIndex()]["[" target_section "]"] := [key "=" value, " "]
return this.edit(key, value, target_section)
}
newKey(key, value, target_section)
{
for index, section_name in this.sections
{
for section_, key_value_pars in section_name
{
if not section_ = "[" target_section "]"
continue
else
{
this.sections[index][section_][this.sections[index][section_].maxindex()] := key "="
this.sections[index][section_].insert(" ")
}
}
}
return this.edit(key, value, target_section)
}
editsection(target_section, new_section)
{
for k, v in this.sections
{
for key, value in v
{
if ( (key = "[" target_section "]")  )
{
this.sections.insert({})
this.sections[this.sections.MaxIndex()]["[" new_section "]"] := value
this.sections.remove(k)
}
}
}
return new_section
}
edit(key, value, target_section = "")
{
if ! target_section
target_section := this.orfans
section_found := false
key_found := false
for index, section_name in this.sections
{
for section_, key_value_pars in section_name
{
if not section_ = "[" target_section "]"
continue
else section_found := True
for index_, value_ in key_value_pars
{
stringsplit, par, value_, =
if (par1 = key)
{
this.sections[index][section_][index_] := key "=" value
key_found := True
}
}
}
}
if (section_found = false)
return this.newSection(key, value, target_section)
if (key_found = false)
return this.newKey(key, value, target_section)
return
}
save()
{
string := ""
for k, v in this.sections
{
for key, value in v
{
if not key = "[" this.orfans "]"
string .= key "`r`n"
for key_, value_ in value
string .= value_ "`r`n"
}
string := Rtrim(string, omitchars = " `r`n")
}
string := Ltrim(string, omitchars = "`r`n")
filedelete, % this.file
fileappend, % string, % this.file
return 0
}
isSectionName(string)
{
if this.stringEndsWith(string, "]") and this.stringStartsWith(string, "[")
return True
return false
}
stringEndsWith(string, char_)
{
if InStr(string, char_ , StartingPos = 0) = Strlen(string)
return True
return False
}
stringStartsWith(string, char_)
{
if InStr(string, char_ , StartingPos = 1) = 1
return True
return false
}
}
Class Ini extends IniFast {
}
GUID_FromString(ByRef GUID, String) {
VarSetCapacity(GUID, 16, 0)
StringReplace,String,String,-,,All
NumPut("0x" . SubStr(String, 2, 8), GUID, 0, "UInt")
NumPut("0x" . SubStr(String, 10, 4), GUID, 4, "UShort")
NumPut("0x" . SubStr(String, 14, 4), GUID, 6, "UShort")
Loop, 8
NumPut("0x" . SubStr(String, 16+(A_Index*2), 2), GUID, 7+A_Index, "UChar")
}
GUID_ToString(ByRef GUID) {
format := A_FormatInteger
SetFormat, Integer, H
str .= SubStr(NumGet(GUID, 0, "UInt"),3) . "-"
str .= SubStr(NumGet(GUID, 4, "UShort"),3) . "-"
str .= SubStr(NumGet(GUID, 6, "UShort"),3) . "-"
Loop, 8
str .= (A_Index = 2) ? SubStr(NumGet(GUID, 7+A_Index, "UChar"),3) . "-" : SubStr(NumGet(GUID, 7+A_Index, "UChar"),3)
SetFormat, Integer, %format%
return "{" . str . "}"
}
class __Syslinks__
{
__delete()
{
file  := fileopen(g_.injector_dir "\SystemLinks.log", "r")
while (l := file.ReadLine())
{
line  := trim(line, "`r")
line  := trim(line, "`n")
line  := trim(line, "`r")
FileDelete, %line%
}
}
}
class Syslinks
{
__new(gdir, sdir)
{
this.gdir  := gdir
this.sdir  := sdir
this.links := {}
this.log  := fileopen(g_.injector_dir "\file.log", "w")
this.log.write("Gamedir  " gdir "`n")
this.log.write("Savesdir " sdir "`n")
this.log.write("Files to create links for" "`n")
this.files := this.ListGameFiles(gdir)
loop, Files, %sdir%\*.*, r
{
lnk := StrReplace(A_LoopFileFullPath, sdir, gdir)
SplitPath, lnk, , OutDir,
if (!Fileexist(OutDir))
{
this.log.write("Create dir : " OutDir "`n")
FileCreateDir, % OutDir
}
this.log.write("Create link: " lnk "`n")
this.log.write("For file   : " A_LoopFileFullPath "`n")
if (dllcall("CreateSymbolicLinkW", str, lnk, str, A_LoopFileFullPath, uint, 0, uint) )
this.links[A_LoopFileFullPath] := lnk
}
this.log.write("Game files:`n")
for k, v in this.files
this.log.write(k "`n")
}
ListGameFiles(gdir)
{
files := {}
loop, Files, %gdir%\*.*, r
files[A_LoopFileFullPath] := True
return files
}
__delete()
{
for k, v in this.links
{
att := dllcall("GetFileAttributesW", str, v)
if ( (att & 0x400) && (att>0) )
{
this.log.write(v " is shortcut `n")
FileDelete, % v
}
else
{
this.log.write("deleting  :  " k "`n")
FileDelete, % k
}
}
for k, v in this.ListGameFiles(this.gdir)
{
if (! this.files[k] )
{
backup := StrReplace(k, this.gdir, this.sdir)
SplitPath, backup, , OutDir,
this.log.write("Created:  " k "`n")
this.log.write("Backup :  " backup "`n")
this.log.write("at     :  " OutDir "`n")
if (!Fileexist(OutDir))
FileCreateDir, % OutDir
FileMove, % k, % backup
}
}
this.log.close()
new __Syslinks__()
}
}
if (instr(g_.svs, "links_cpp"))
Syslinks = __Syslinks__
SetBatchLines, -1
regwrite, REG_SZ, HKCU, Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers, %A_scriptFullPath%, HIGHDPIAWARE
RunAsAdmin()
if (tool := GetCommandLineValueB("-tool:"))
{
script := LoadResource("remote_lib.txt") "`n"
script .= LoadResource("HelpEx.txt", "Help.exe") "`n"
for k, v in GetScriptParamsAsList()
{
if instr(v, ".txt")
{
stringreplace, vv, v, /, ,
script .= "`n" LoadResource(vv)
}
}
fileread, s, Tools\%tool%.ahk
script .= "`n" s
dlls       := "\Autohotkey\dlls\"
_pex       := FileExist(A_scriptdir "\peixoto.dll") ? A_scriptdir "\peixoto.dll" : A_mydocuments dlls "peixoto.dll"
dllcall("LoadLibraryW", str, _pex)
_ahk       := FileExist(A_scriptdir "\AutoHotkey.dll") ? A_scriptdir "\AutoHotkey.dll" : A_mydocuments dlls "AutoHotkey.dll"
ahktextdll := dllcall("GetProcAddress", uint, dllcall("LoadLibraryW", str, _ahk), astr, "ahktextdll")
hThread    := dllcall(ahktextdll, Str, "#NoTrayIcon`n" script, Str, "", Str, "", "Cdecl UPTR")
dllcall("WaitForSingleObject", "ptr", hThread, "uint", 0xffffffff)
exitapp
}
if instr(dllcall("GetCommandLine", str), "/wait")
{
global g_, g_hhookex, g_games := {}
loop, scripts\*.ini
{
g := new ini(A_LoopFileFullPath).read("target")
print(A_LoopFileFullPath " " g "`n")
g_games[g] := A_LoopFileFullPath
}
loop, user\*.ini
{
g := new ini(A_LoopFileFullPath).read("target")
print(A_LoopFileFullPath " " g "`n")
g_games[g] := A_LoopFileFullPath
}
OnMessage(dllcall("RegisterWindowMessageW", str, "Peixoto.FindTarget"), "FindTarget")
_pex      := FileExist(A_scriptdir "\peixoto.dll") ? A_scriptdir "\peixoto.dll" : A_mydocuments "\Autohotkey\dlls\peixoto.dll"
hPex      := dllcall("LoadLibraryW", str, _pex)
hProc     := dllcall("GetProcAddress", uint, hPex, astr, "CBTProc")
g_hhookex := dllcall("SetWindowsHookExA", uint, 5, uint, hProc, uint, hPex, uint, 0)
gui, add, text, ,Waiting
gui, show
return
}
FindTarget(w, l, m, h)
{
VarSetCapacity(n, 520)
hP   := dllcall("OpenProcess", uint, 0x0400, uint, 1, uint, w)
r    := dllcall("psapi.dll\GetModuleFileNameExA", uint, hP, uint, 0, uint, &n, uint, 520)
name := strget(&n, "UTF-8")
if (file := g_games[name])
{
g_   := ParseCommandLine(file)
dlls := "\Autohotkey\dlls\"
_ahk := FileExist(A_scriptdir "\AutoHotkey.dll") ? A_scriptdir "\AutoHotkey.dll" : A_mydocuments dlls "AutoHotkey.dll"
g_.proc := {"hProcess" : get_process_handle(g_.target_name)}
dllcallEx(g_.proc.hProcess, "Kernel32.dll", "LoadLibraryW", _ahk)
GetRemoteScript()
FileDelete, last
fileappend, % g_.remoteScript, last
print("Attached to " strget(&n, "UTF-8") "`n")
return g_hhookex
}
print("Attached to " strget(&n, "UTF-8") " " success "`n")
return
}
if not dllcall("LoadLibraryW", str, "d3dx9_43.dll")
msgbox, 16, ,Failed to load D3Dx9_43.dll, some features will not work, make sure DirectX is up to date
OnMessage(0x4a, "ProcNameMessage")
OnMessage(dllcall("RegisterWindowMessageW", str, "Peixoto.Hwnd"), "ProcHwndMessage")
OnMessage(dllcall("RegisterWindowMessageW", str, "Peixoto.MCI"), "MCI")
OnMessage(dllcall("RegisterWindowMessageW", str, "Peixoto.Thread"), "StartDll")
OnMessage(dllcall("RegisterWindowMessageW", str, "Peixoto.Inject"), "InjectMsg")
global g_ := ParseCommandLine()
CheckTarget()
launchTarget()
launchTarget()
{
print("`r")
dlls := "\Autohotkey\dlls\"
_ahk := FileExist(A_workingdir "\AutoHotkey.dll") ? A_workingdir "\AutoHotkey.dll" : A_mydocuments dlls "AutoHotkey.dll"
_pex := FileExist(A_workingdir "\peixoto.dll") ? A_workingdir "\peixoto.dll" : A_mydocuments dlls "peixoto.dll"
_ahk := A_workingdir "\AutoHotkey.dll"
_pex := A_workingdir "\peixoto.dll"
target := g_.target
splitpath, target, name
process, exist, %name%
fileexist(g_.target) ?: quit(name " not found in`n`n" g_.target_dir)
errorlevel ? quit(name ".exe already running")
dllcall((ld:="LoadLibraryW"), str, _ahk) ?: Quit("Unable to find or load`n" _ahk "-" A_lasterror)
dllcall(ld, str, _pex)                   ?: Quit("Unable to find or load`n" _pex "-" A_lasterror)
c   := Setup()
if (g_.cmmd)
{
args := ""
for k, v in strsplit(g_.cmmd, ";")
args .= strsplit(v, "=")[2] " "
} else	args := g_.args
stringreplace, args, args, `"`"`"`",`",1
g_.args := args
g_.args := """" g_.target_dir "\" g_.target """ " args
g_.args := " " args
g_.args := args
EnvSet, Peixoto.HWND, %A_ScriptHwnd%
if (g_.Nohooks)
{
if (g_.d3d = 10 or g_.d3d = 11)
dllcall("SetDllDirectoryA", astr, g_.injector_dir "\dxvk\" g_.dxvkv "\x32")
g_.proc := CreateIdleProcess(g_.target, g_.target_dir, g_.args,, True)
}
else
{
g_.proc := CreateIdleProcess(g_.target, g_.target_dir, g_.args)
SetupProc(g_.proc.hProcess, name)
Inject(_ahk, _pex)
}
if g_.gamma {
hDC := DllCall("GetDC", "Uint", 0)
VarSetCapacity(gramp, 256*6)
DllCall("GetDeviceGammaRamp", "Uint", hDC, "Uint", &gramp)
DllCall("ReleaseDC", "Uint", 0, "Uint", hDC)
}
id := g_.proc.Process_id
process, Exist, %id%
while ErrorLevel
{
sleep, 100
id := g_.proc.Process_id
process, Exist, %id%
if getkeystate("ctrl", "p") && getkeystate("alt", "p") & getkeystate("del", "p")
process, close, %id%
}
links := ""
CleanUP(c, &gramp)
exitapp
}
InjectMsg(h, m, w, l)
{
dlls := "\Autohotkey\dlls\"
_ahk := FileExist(A_workingdir "\AutoHotkey.dll") ? A_workingdir "\AutoHotkey.dll" : A_mydocuments dlls "AutoHotkey.dll"
_pex := FileExist(A_workingdir "\peixoto.dll") ? A_workingdir "\peixoto.dll" : A_mydocuments dlls "peixoto.dll"
_ahk := A_workingdir "\AutoHotkey.dll"
_pex := A_workingdir "\peixoto.dll"
Inject(_ahk, _pex)
return
}
Inject(_ahk, _pex)
{
while ! g_.proc.hProcess
continue
dllcallEx(g_.proc.hProcess, "Kernel32.dll", "LoadLibraryW", _ahk)
dllcallEx(g_.proc.hProcess, "Kernel32.dll", "LoadLibraryW", _pex)
GetRemoteScript()
FileDelete, last
fileappend, % g_.remoteScript, last
success := dllcallEx(g_.proc.hProcess, "peixoto.dll", "RunScript", A_workingdir "\last")
if (success = 2)
{
quit("Could not allocate memory for dll injection: " A_lasterror)
}
else if (success = 3)
quit("Could not write to memory allocated for dll injection " A_lasterror)
else if (success = 4)
quit("Could not create remote thread for dll injection " A_lasterror)
}
SetupProc(hProc, name)
{
if (g_.singlecore)
{
i := 12
S := 0
while (!s)
{
s := dllcall("SetProcessAffinityMask", uint, hProc, uint, 1 << i, uint)
i-= 1
}
}
print("hProc " hProc "`n")
if (g_.D3D > 0 and g_.D3D < 4)
{
dllcallEx(g_.proc.hProcess, "Kernel32.dll", "LoadLibraryW", "D3Dim.dll")
loop, 2
{
ad := aobscan(hProc, get_process_ID(name), "D3Dim.dll", memlib_String2ByteArray("B8 00 08 00 00 39"), "peixoto.dll")
if ad is number
write_process_memory(hProc, ad+1, "array", [0x00, 0x20, 0x00, 00])
}
}
else if (g_.D3D = 7)
{
dllcallEx(g_.proc.hProcess, "Kernel32.dll", "LoadLibraryW", "d3dim700.dll")
while ! find_module("d3dim700.dll", g_.proc.Process_id)
continue
loop, 2
{
ad := aobscan(g_.proc.hProcess, g_.proc.Process_id, "d3dim700.dll", memlib_String2ByteArray("B8 00 08 00 00 39"), "peixoto.dll")
if ad is number
write_process_memory(g_.proc.hProcess, ad+1, "array", [0x00, 0x20, 0x00, 00])
}
}
print("hProc " g_.proc.hProcess "`n")
}
Setup()
{
cmpt           := g_.compatLayer
(g_.HDPI)      ? cmpt .= cmpt ? " HIGHDPIAWARE" : "HIGHDPIAWARE"
(g_.D3D=1||g_.D3D=2||g_.D3D=3||g_.D3D=7) ? cmpt .= cmpt ? " DWM8And16BitMitigation" : "DWM8And16BitMitigation"
print("Changing compability for " g_.target " " cmpt " " g_.s_cmptlr "`n")
chng           := g_.target
if (cmpt != "#")
{
regwrite, REG_SZ, HKCU, Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers, %chng%, ~ %cmpt%
EnvSet, __COMPAT_LAYER, %cmpt%
}
if (g_.rnm)
{
RegDelete, HKLM, Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Custom, %chng%
RegDelete, HKLM, Software\Microsoft\Windows NT\CurrentVersion\AppCompatFlags\Layers, %chng%
}
if g_.DSR
{
VarSetCapacity(DM, 156, 0)
NumPut(156, DM, 36,"ushort")
DllCall("EnumDisplaySettingsA", uint, 0, uint, -1, uint, &DM)
cw := NumGet(DM, 108, "uint")
ch := NumGet(DM, 112, "uint")
res := strsplit(g_.dsr, "x")
Numput(res[1], &DM+108, "uint")
Numput(res[2], &DM+112, "uint")
DllCall("ChangeDisplaySettingsA", uint, &DM, uint, 0)
}
if g_.SXTY
{
dllcall("peixoto.dll\GDISetHz", uint, 60)
}
return [cw, ch]
}
CleanUP(c, byref cramp)
{
if g_.DSR
{
VarSetCapacity(DM, 156, 0)
NumPut(156, DM, 36,"ushort")
DllCall("EnumDisplaySettingsA", uint, 0, uint, -1, uint, &DM)
Numput(c[1], &DM+108, "uint")
Numput(c[2], &DM+112, "uint")
DllCall("ChangeDisplaySettingsA", uint, &DM, uint, 0)
}
if g_.gamma {
hDC := DllCall("GetDC", "Uint", 0)
DllCall("SetDeviceGammaRamp", "Uint", hDC, "Uint", cramp)
DllCall("ReleaseDC", "Uint", 0, "Uint", hDC)
}
if g_["LNKS"]
{
lnk := g_.target_dir "\" g_["lnks"]
Print("`nRemoving simbolic link : " lnk)
fileremovedir, %lnk%
}
}
ProcNameMessage(W, L)
{
trgt := StrGet( NumGet(L+8), NumGet(L+4), "UTF-16" )
splitpath, trgt, name, dir
g_.target       := trgt
g_.target_dir   := dir
g_.target_name  := name
print( "Recived " StrGet( NumGet(L+8), NumGet(L+4), "UTF-16" ) "`n")
Setup()
return
}
Is64Bit(){
r := dllcall("GetBinaryType", astr, g_.target, "uint*", target)
return r > 0 and target = 6
}
ProcHwndMessage(w, l)
{
print("ProcHwndMessage recived`n")
if Is64Bit(){
cmd  := StrSplit(dllcall("GetCommandLineW", str), "-f"" ")[2]
trgt := g_.target
run, Injector64.exe src/injector64.txt -f %cmd% -32bitparent "%trgt%"
sleep, 1000
OnMessage(dllcall("RegisterWindowMessageW", str, "Peixoto.Hwnd"), "")
dllcall("PostMessageW", uint, 0xffff, uint, dllcall("RegisterWindowMessageW", str, "Peixoto.Hwnd")
, uint, w, uint, l)
exitapp
}
g_.proc            := {}
g_.proc.hProcess   := w
g_.proc.hProcess   := dllcall("OpenProcess", uint, 0x30|0x02|0x08|0x00100000|0x0200, uint, 0, uint, l)
g_.proc.Thread_id  := w
g_.proc.Process_id := l
SetupProc(g_.proc.hProcess, g_.target_name)
dlls := "\Autohotkey\dlls\"
_ahk := FileExist(A_workingdir "\AutoHotkey.dll") ? A_workingdir "\AutoHotkey.dll" : A_mydocuments dlls "AutoHotkey.dll"
_pex := FileExist(A_workingdir "\peixoto.dll") ? A_workingdir "\peixoto.dll" : A_mydocuments dlls "peixoto.dll"
_ahk := A_workingdir "\AutoHotkey.dll"
_pex := A_workingdir "\peixoto.dll"
Inject(_ahk, _pex)
return
}
GetRemoteScript()
{
g_.remoteScript := ""
if g_.console
g_.remoteScript := "#warn all, OutputDebug`n"
g_.remoteScript := "global g_MainThreadID := " g_.proc.Thread_id " `;<Tag> `n" g_.remoteScript
g_.remoteScript .= "global g_cmdstring := """ g_.cmdstring """`n"
g_.remoteScript .= LoadResource("remote_lib.txt")
g_.remoteScript .= "`n" LoadResource("CreateProcessHooks.txt")
g_.remoteScript .= "`n" LoadResource("..\Xinput.ahk")
if (Parsecfg(g_.WNMM).MCI)
{
g_.remoteScript .= "`n" LoadResource("MCI.txt")
if g_.console
{
fileread, MCIDbug, dev\MCI Debug.ahk
g_.remoteScript .= "`n" MCIDbug
}
}
if g_.dshow or Parsecfg(g_.J2K).u
g_.remoteScript .= LoadResource("Xinput.txt") "`n"
if g_.dshow
g_.remoteScript .= "`n`r" LoadResource("dshow.hooks.txt")
if Parsecfg(g_.dsnd).e
g_.remoteScript .= "`n`r" LoadResource("dsound.hooks.txt")
if Parsecfg(g_.J2K).u
g_.remoteScript .= "`n" LoadResource("dinput.hooks.txt") "`n"
if (g_.D3D > 0 and g_.D3D < 4) or (g_.D3D = 7) or (g_.ddraw)
g_.remoteScript .= "`n" LoadResource("D3D_DDI.Hooks.txt") "`n" LoadResource((g_.ver or g_.layeroff) ? "D3D.Legacy.hooks.txt" : "D3D.hooks.txt") "`n" LoadResource("WinAPI.hooks.txt")
else if (g_.D3D = 8)
g_.remoteScript .=  "`n" LoadResource("D3D_DDI.Hooks.txt") "`n" LoadResource("D3DX9.txt") "`n" LoadResource("D3D8.hooks.txt")
else if (g_.D3D = 9)
g_.remoteScript .=  "`n" LoadResource("D3DX9.txt") "`n" LoadResource("D3D9.hooks.txt")
else if (g_.D3D = "gl")
g_.remoteScript .= "`n" LoadResource("gl.hooks.txt")
else if (g_.D3D = 11 or g_.D3D = 10)
g_.remoteScript .= "`n" LoadResource("D3D11.hooks.txt") "`n" LoadResource("HLSLGen.txt")
if g_.Script
{
g_.ex_script := LoadResource("exlib.txt") "`n"
g_.ex_script .= LoadResource("Xinput.txt") "`n"
script_file  := A_mydocuments "\WineHooks\" g_.Script
if fileexist(script_file)
{
fileread, script, %script_file%
script := strsplit(script, ";REMOTE SCRIPT START")
g_.remoteScript .= "`n" script[2] "`n"
g_.ex_script .= "`n" script[1]
} else {
script := strsplit(script_file, "|")
g_.remoteScript .= "`n" script[2] "`n"
g_.ex_script .= "`n" script[1]
}
} else if g_.J2K or g_.K2K
{
g_.ex_script := LoadResource("exlib.txt") "`n"
g_.ex_script .= LoadResource("Xinput.txt") "`n"
}
if ! g_.console
g_.remoteScript .= "`nprintl()"
(g_.D3D > 0 and g_.D3D < 4) or (g_.ddraw) ? g_.remoteScript .= "`n" "ReleaseDirectDraw()`n"
g_.remoteScript .= "`nresume()"
}
CompileScript(script)
{
if A_iscompiled
return
splitpath, script, , , ,name
runwait, Ahk2Exe.exe /in %script% /out %name%.exe
txt := LoadResource(">AUTOHOTKEY SCRIPT<", name ".exe")
filedelete, %name%.txt
fileappend, %txt%, %name%.txt
}
LoadResource(res, _mod = "")
{
return fileopen("src\" res, "r").read()
}
CheckTarget()
{
r := dllcall("GetBinaryType", astr, g_.target, "uint*", target)
if (target = 0) and r
return
else if (target = 6) {
cmd_line := dllcall("GetCommandLineW", str)
cmd      := instr(cmd_line , "-f"" ") ? StrSplit(cmd_line, "-f"" ")[2] :  StrSplit(cmd_line, "-f ")[2]
run, Injector64.exe src/injector64.txt -f %cmd%
ExitApp
} else quit(g_.target " is not a valid windows 32 or 64 bit program")
}
MCI(wP, lParam, msg, hwnd)
{
critical
static from, to, hEvent, Ntf, pNtf
static sndbuff=0, vol:=0, volr:=0xffff, tracks, last, lg, reply, flags, hwin, path := "\"
if (wP = 1)
{
if isobject(IDirectSound)
return
hEvent     := dllcall("CreateEventW", uint, 0, uint, 1, uint, 1, str, "Peixoto.MCI", uint)
Ntf        := struct("LPVOID hEvent; DWORD hwin; DWORD Abrt; DWORD ANtf; DWORD SB;")
Ntf.hEvent := hEvent
pNtf       := dllcall("GetProcAddress", uint, dllcall("GetModuleHandle", str, "peixoto.dll"), astr, "MCINofify", uint)
reply      := dllcall("GetProcAddress", uint, dllcall("LoadLibraryW", str, "User32.dll"), astr, "ReplyMessage", uint)
lg         := g_.injector_dir "\error.log"
tracks     := []
GetDSound(hwin := dllcall("GetForegroundWindow", uint))
ms         := 0
total      := 0
Loop
{
track := g_.target_dir path GetTrackName(A_index)
if ! fileexist(track)
break
if fileexist(track)
{
t     := GetWAVInfo(track)
t.ms  := ms
ms    := t.ms + t._ms
t.pos := total
tracks.insert(t)
ts .= track " " t.m " minutes :" t.s " seconds :" t.f " frames - total: " t.t " seconds`n"
total += t._ms
} else break
}
out := "OPEN:`n"
for i, t in tracks
out .=  "`t track " i ": " t.m " minutes :" t.s " seconds :" t.f " frames - total: " t._ms " mili seconds, position(ms):" t.pos "`n"
MCILog(rtrim(out, "`n"))
}
else if (wP = 2)
{
path := (lParam) ? "\Disk2\" : "\"
if isobject(IDirectSound)
return
Ntf.Abrt := 1
Ntf.ANtf := 0
dllcall(sndbuff.stop, uint, sndbuff.p)
dllcall("SetEvent", uint, hEvent)
dllcall(sndbuff.release, uint, sndbuff.p)
sndbuff  := 0
tracks   := []
ms       := 0
Loop
{
track := g_.target_dir path GetTrackName(A_index)
if fileexist(track)
{
t    := GetWAVInfo(track)
t.ms := ms
ms   := t.ms + t._ms
tracks.insert(t)
ts .= track " " t.m " minutes :" t.s " seconds :" t.f " frames - total: " t.t " seconds`n"
} else break
}
return dllcall(reply, uint, wp)
}
else if (wp = 6)
{
from := lParam
}
else if (wp = 7)
{
to   := lParam
}
else if (wp = 3)
{
t := 0
for k, v in tracks
{
if (t >= from)
{
from := k+1
break
}
t += MSF_to_MScnd(v)
}
to := from
}
else if (wp = 8)
{
fcs      := (hwin != dllcall("GetForegroundWindow"))
t0       := (from & 0xff)-1
tf       := (to   & 0xff)-1
offset   := (from & 0xffffff)
if (tf = t0)
tf       := t0+1
ntracks  := tf-t0
last	 := t0
fcs      := hwin != dllcall("GetForegroundWindow", uint) ? 1 : 0
if isobject(sndbuff)
{
Ntf.Abrt := 1
Ntf.ANtf := 0
dllcall(sndbuff.stop, uint, sndbuff.p)
dllcall("SetEvent", uint, hEvent)
dllcall(sndbuff.release, uint, sndbuff.p)
sndbuff  := 0
}
dllcall("ResetEvent", uint, hEvent)
if ((ntracks > 1) && (ntracks <= (tracks._MaxIndex() - t0)))
sndbuff      := loadWAVS(g_.target_dir path, t0, ntracks)
else sndbuff := InjectorLoadWAV(g_.target_dir path GetTrackName(t0),,fcs)
if (!isobject(sndbuff))
{
dllcall("SetEvent", uint, hEvent)
return
}
if (offset)
{
dllcall(sndbuff.GetFormat, uint, sndbuff.p, uint, WAVEFORMATEX[], uint, WAVEFORMATEX.size(), "uint*", p4)
scds   := (offset & 0xff0000)      >> 16
scds   += (offset & 0xff00)*60     >> 8
scds   += (offset & 0xff000000)/75 >> 24
smpls  := WAVEFORMATEX.nSamplesPerSec*scds
bytes  := WAVEFORMATEX.wBitsPerSample*smpls*WAVEFORMATEX.nChannels/8
dllcall(sndbuff.SetCurrentPosition, uint, sndbuff.p, uint, bytes)
}
v := dllcall(sndbuff.SetVolume, uint, sndbuff.p, int, vol, uint)
v .= dsound.err[v . ""]
Ntf.hWin := lParam&0xffff
Ntf.Abrt := 0
Ntf.ANtf := 0
dllcall(sndbuff.play, uint, sndbuff.p, uint, 0, uint, 0, uint, f, uint)
Ntf.SB := sndbuff.p
if (Ntf.hWin)
dllcall("CreateThread", ptr, 0, uint, 0, ptr, pNtf, ptr, Ntf[], uint, 0, uint, 0)
MCILog("Play " ntracks " tracks, " t0 " to " t1 ": " GetTrackName(t0))
}
else if (wp = 9)
{
return dllcall(reply, uint, 1)
}
else if ( (wP = 4) || (wP = 5) )
{
if ! isobject(sndbuff)
return
Ntf.Abrt := 1
Ntf.ANtf := lParam
dllcall(sndbuff.stop, uint, sndbuff.p)
dllcall("SetEvent", uint, hEvent)
return dllcall(reply, uint, wp)
}
else if (wP = 11)
{
if (lParam = 1)
lParam := 2
t := tracks[lParam-1]
dllcall(reply,uint,TMSF(t)>>8)
}
else if (wP = 104)
{
if ! isobject(sndbuff)
return dllcall(reply, uint, 525)
r := dllcall(sndbuff.GetStatus, uint, sndbuff.p, "uint*", _status)
return dllcall(reply, uint, (_status & DSBSTATUS_PLAYING) ? 526 : 525)
}
else if (wP = 103)
{
return dllcall(reply, uint, tracks._MaxIndex()+1)
}
else if (wP = 102)
{
if ! isobject(sndbuff)
dllcall(reply, uint, 2)
play := 0
w    := 0
p := dllcall(sndbuff.GetCurrentPosition, uint, sndbuff.p, "uint*", play, "uint*", w)
f := dllcall(sndbuff.GetFormat, uint, sndbuff.p, uint, WAVEFORMATEX[], uint, WAVEFORMATEX.size(), "uint*", sz:=0)
t := WavTime(play, WAVEFORMATEX)
if !lparam
dllcall(reply, uint, last+1 | TMSF(t))
else if lparam
dllcall(reply, uint, tracks[last].ms + t._ms)
}
else if (wP = 120)
{
t := tracks[lParam-1]
p := 0
for k, v in tracks
{
if (k = lParam-1)
return dllcall(reply, uint, p)
print("track " k " " MSF_to_MScnd(v) " milisseconds`n")
p += MSF_to_MScnd(v)
}
}
else if (wP = 110)
{
if (lParam = 1)
lParam := 2
t := tracks[lParam-1]
dllcall(reply, uint, MSF_to_MScnd(t))
}
else if (wP = 1000)
{
volr := lParam
vol  := volr ? (log(volr&0xFFFF)*10000/log(0xFFFF))-10000 : -10000
if isobject(sndbuff)
{
dllcall(sndbuff.GetStatus, uint, sndbuff.p, "uint*", stts)
(stts & 1) ? dllcall(sndbuff.stop, uint, sndbuff.p)
dllcall(sndbuff.SetVolume, uint, sndbuff.p, int, vol)
(stts & 1) ? dllcall(sndbuff.play, uint, sndbuff.p, uint, 0, uint, 0, uint, flags, uint)
}
}
else if (wP = 3000)
{
volr := lParam
vol  := volr ? (log(volr)*10000/log(1000))-10000 : -10000
if isobject(sndbuff)
{
dllcall(sndbuff.GetStatus, uint, sndbuff.p, "uint*", stts)
(stts & 1) ? dllcall(sndbuff.stop, uint, sndbuff.p)
dllcall(sndbuff.SetVolume, uint, sndbuff.p, int, vol)
(stts & 1) ? dllcall(sndbuff.play, uint, sndbuff.p, uint, 0, uint, 0, uint, flags, uint)
}
}
else if (wP = 2000)
dllcall("ReplyMessage", uint, volr)
return 0
}
GetDSound(hwin)
{
return GetDirectSound(hwin)
GetDirectSound8(hwin)
GUID_FromString(iid, dsound.IDirectSound)
r := dllcall(IDirectSound8.QueryInterface, uint, IDirectSound8.p, uint, &iid, "uint*", pDS:=0)
if r
return "Failed to create the IDirectSound interface " r dsound.err[r . ""]
IDirectSound := new ComInterfaceWrapper(dsound.IDirectSound, pDS, True)
GUID_FromString(iid, dsound.IDirectSoundBuffer)
r := dllcall(IDirectSoundBuffer8.QueryInterface, uint, IDirectSoundBuffer8.p, uint, &iid, "uint*", pDSb:=0)
if r
return "Failed to create the IDirectSoundBuffer interface " r  " - " dsound.IID_IKsPropertySet " " dsound.err[r . ""]
IDirectSoundBuffer := new ComInterfaceWrapper(dsound.IDirectSoundBuffer, pDSb, True)
}
MSF_to_MScnd(msf)
{
m := msf.m * 60 * 1000
m += msf.s * 1000
m += msf.f * 1000 / 75
return m
}
TMSF(t)
{
return (t.m << 8) | (t.s << 16) | (t.f << 24)
}
InjectorLoadWAV(file_, formatcheck = True, fcs = False)
{
plock:=0, plocksize:=0
file := FileOpen(file_, "r")
if (!isobject(file))
return 0
VarSetCapacity(data, file.Length)
file.RawRead(data, file.Length)
file.close()
loop, % file.Length
{
if strget(&data + A_index, 3, "CP0") = "fmt"
{
index := A_index + 8
break
}
}
if not index
return "File format must be .wav (PCM)"
VarSetCapacity(wav, sizeof(WAVEFORMATEX))
dllcall("RtlMoveMemory", ptr, &wav, ptr, &data + index, int, sizeof(WAVEFORMATEX))
WAVEFORMATEX[] := &wav
if 	WAVEFORMATEX.wFormatTag = 1
WAVEFORMATEX.wFormatTag := WAVE_FORMAT_PCM
else
if formatcheck
return "WAV file must be on PCM format"
loop, % file.Length
{
if strget(&data + A_index, 4,"CP0") = "data"
{
index := A_index
break
}
}
data_size := numget(&data + index + 4, "int")
VarSetCapacity(wave_data, data_size)
dllcall("RtlMoveMemory", ptr, &wave_data, ptr, &data + index + 8, int, data_size)
DSBUFFERDESC.dwSize        := sizeof(DSBUFFERDESC)
DSBUFFERDESC.dwFlags       := DSBCAPS_CTRLVOLUME | DSBCAPS_LOCSOFTWARE
DSBUFFERDESC.dwBufferBytes := data_size
DSBUFFERDESC.lpwfxFormat   := WAVEFORMATEX[]
fcs ? DSBUFFERDESC.dwFlags |= (DSBCAPS_STICKYFOCUS | DSBCAPS_GLOBALFOCUS )
DSBUFFERDESC.dwFlags |= (DSBCAPS_STICKYFOCUS | DSBCAPS_GLOBALFOCUS )
buff := 0
r := dllcall(IDirectSound.CreateSoundBuffer, uint, IDirectSound.p, uint, DSBUFFERDESC[], "uint*", buff, uint, 0, uint)
if r
return r  " CreateSoundBuffer " dsound.err[r . ""]
sndbuff := new ComInterfaceWrapper(dsound.IDirectSoundBuffer, buff, True)
r := dllcall(sndbuff.Lock, uint, sndbuff.p, uint, 0, uint, data_size, "uint*", plock
, "uint*", plocksize, uint, 0, uint, 0, uint, DSBLOCK_ENTIREBUFFER, uint)
if r
return r  " Lock " dsound.err[r . ""]
dllcall("RtlMoveMemory", ptr, plock, ptr, &wave_data, int, data_size)
r := dllcall(sndbuff.UnLock, uint, sndbuff.p, uint, plock, uint, data_size, uint, 0, uint, 0, uint)
if r
return r  " Unlock " dsound.err[r . ""]
wav := ""
wave_data := ""
return sndbuff
}
loadWAVS(dir, strt, n)
{
lg     := g_.injector_dir "\error.log"
sz     := 0
loop, %n%
{
f := GetTrackName(strt+A_index-1)
f := FileOpen(dir "\" f, "r")
if (!isobject(f))
return
loop
{
if (f.Read(3) = "fmt" )
break
f.seek(A_index, 0)
}
f.seek(5, 1)
f.RawRead(WAVEFORMATEX[], sizeof(WAVEFORMATEX))
if 	WAVEFORMATEX.wFormatTag <> 1
return "WAV file must be on PCM format"
loop
{
if (f.Read(4) = "data")
break
f.seek(A_index, 0)
}
sz += f.ReadInt()
f.close()
}
DSBUFFERDESC.dwSize        := sizeof(DSBUFFERDESC)
DSBUFFERDESC.dwFlags       := DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_LOCSOFTWARE
DSBUFFERDESC.dwBufferBytes := sz
DSBUFFERDESC.lpwfxFormat   := WAVEFORMATEX[]
r       := dllcall(IDirectSound.CreateSoundBuffer, uint, IDirectSound.p, uint, DSBUFFERDESC[], "uint*", buff, uint, 0, uint)
r       :=  "CreateSoundBuffer " r " " dsound.err[r . ""] "`n"
sndbuff := new ComInterfaceWrapper(dsound.IDirectSoundBuffer, buff, True)
VarSetCapacity(buff_data, sz)
sz      := 0
loop, %n%
{
f := GetTrackName(strt+A_index-1)
file := FileOpen(dir "\" f, "r")
VarSetCapacity(data, file.Length)
file.RawRead(data, file.Length)
file.close()
loop, % file.Length
{
if strget(&data + A_index, 3, "CP0") = "fmt"
{
index := A_index + 8
break
}
}
if not index
return "File format must be .wav (PCM)"
VarSetCapacity(wav, sizeof(WAVEFORMATEX))
dllcall("RtlMoveMemory", ptr, &wav, ptr, &data + index, int, sizeof(WAVEFORMATEX))
WAVEFORMATEX[] := &wav
if 	WAVEFORMATEX.wFormatTag = 1
WAVEFORMATEX.wFormatTag := WAVE_FORMAT_PCM
else
if formatcheck
return "WAV file must be on PCM format"
loop, % file.Length
{
if strget(&data + A_index, 4,"CP0") = "data"
{
index := A_index
break
}
}
data_size := numget(&data + index + 4, "int")
dllcall("RtlMoveMemory", ptr, &buff_data+sz, ptr, &data + index + 8, int, data_size)
sz += data_size
}
r  := dllcall(sndbuff.Lock, uint, sndbuff.p, uint, 0, uint, sz, "uint*", plock
, "uint*", plocksize, uint, 0, int, 0, uint, DSBLOCK_ENTIREBUFFER, uint)
dllcall("RtlMoveMemory", ptr, plock, ptr, &buff_data, int, plocksize)
r  := dllcall(sndbuff.UnLock, uint, sndbuff.p, uint, plock, uint, plocksize, uint, 0, int, 0, uint)
return sndbuff
}
GetTrackName(n)
{
frmt := A_FormatInteger
setformat, integer, D
((trck := n)<10) ? append := true
trck   := trck " Track " trck ".wav"
append ? trck := "0" trck
setformat, integer, %frmt%
return trck
}
GetWAVInfo(f)
{
f := FileOpen(f, "r")
loop
{
if (f.Read(3) = "fmt" )
break
f.seek(A_index, 0)
}
f.seek(5, 1)
f.RawRead(WAVEFORMATEX[], sizeof(WAVEFORMATEX))
if 	WAVEFORMATEX.wFormatTag <> 1
return "WAV file must be on PCM format"
loop
{
if (f.Read(4) = "data")
break
f.seek(A_index, 0)
}
sz := f.ReadInt()
f.close()
return WavTime(sz, WAVEFORMATEX)
}
WavTime(sz, byref fmt)
{
sz_bts     := (sz*8)/fmt.nChannels
smpls      := sz_bts/fmt.wBitsPerSample
scnds      := smpls/fmt.nSamplesPerSec
mnts       := floor(scnds/60)
scnds      := scnds-(mnts*60)
frame      := abs((scnds-floor(scnds))*(-75))
scnds      := floor(scnds)
return {"m" : mnts, "s" : scnds, "f" : round(frame), "t" : sz_bts/fmt.wBitsPerSample, "_ms" : smpls/fmt.nSamplesPerSec*1000}
}
MCIGetWAVInfo(f)
{
VarSetCapacity(stat, 50)
dllcall("Winmm.dll\mciSendStringA", astr, "open """ f """ type waveaudio alias voice1", uint, 0, uint, 0, uint, 0)
dllcall("Winmm.dll\mciSendStringA", astr, "set voice1 time format ms", uint, 0, uint, 0, uint, 0)
dllcall("Winmm.dll\mciSendStringA", astr, "status voice1 length", uint, &stat, uint, 260, uint, 0)
dllcall("Winmm.dll\mciSendStringA", astr, "close voice1", uint, 0, uint, 0, uint, 0)
return MCIWavTime( strget(&stat, "CP0") )
}
MCIGetWAVSamples(f)
{
VarSetCapacity(stat, 50)
dllcall("Winmm.dll\mciSendStringA", astr, "open """ f """ type waveaudio alias voice1", uint, 0, uint, 0, uint, 0)
dllcall("Winmm.dll\mciSendStringA", astr, "set voice1 time format ms", uint, 0, uint, 0, uint, 0)
dllcall("Winmm.dll\mciSendStringA", astr, "status voice1 length", uint, &stat, uint, 260, uint, 0)
dllcall("Winmm.dll\mciSendStringA", astr, "close voice1", uint, 0, uint, 0, uint, 0)
return strget(&stat, "CP0")
}
MCIWavTime(ms)
{
scnds      := ms/1000
mnts       := floor(scnds/60)
scnds      := scnds-(mnts*60)
frame      := abs((scnds-floor(scnds))*(-75))
scnds      := floor(scnds)
return {"m" : mnts, "s" : scnds, "f" : round(frame), "t" : ms/1000}
}
Class ComInterfaceWrapper
{
__New(byref d, ppIface, v8 = False)
{
this.offsets := {}
n := 0
def := d.def
loop, parse, def, `n
{
if instr(A_loopfield , "STDMETHOD")
{
m := RegExReplace(A_loopfield, "s)\).*" ,"")
m := RegExReplace(m, "s).*\(" ,"")
if instr(m, ",")
{
stringsplit, m_, m,`,
m := trim(m_2)
}
this.offsets[m] := n * A_ptrsize
n += 1
}
}
pIface := v8 ? ppIface : numget(ppIface+0, "ptr")
if pIface
{
Vtbl := numget(pIface + 0, "Ptr")
for k, v in this.offsets
{
vv := numget(Vtbl + v, "Ptr")
this[k] := vv
}
}
this.dwSize   := n*A_ptrsize
this.pVTbl    := Vtbl
this.p        := pIface
this.released := False
}
}
MCILog(t)
{
FileAppend, `tPlay Thread: %t%`n, WinMM.log
}
struct(d){
return new _Struct(d)
}
